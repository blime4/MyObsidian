# 001 - 结构化绑定


## 使用修饰符

```c++
MyStruct ms{42, "hello"};
const auto& [u, v] = ms;    // 引 用， 因 此u/v指 向ms.i/ms.s
```

```c++
MyStruct ms{42, "hello"};
auto& [u, v] = ms;
// 被 初 始 化 的 实 体 是ms的 引 用
ms.i = 77;
// 影 响 到u的 值
std::cout << u;
// 打 印 出77
u = 99;
// 修 改 了ms.i
std::cout << ms.i;
// 打 印 出99
```


## 修饰符并不是作用在结构化绑定引入的变量上

修饰符会作用在新的匿名实体上，而不是结构化绑定引入的新的变量名上。事实上，如下代码中：

```c++
const auto& [u, v] = ms;   // 引 用， 因 此u/v指 向ms.i/ms.s
```


u 和 v 都不是引用，只有匿名实体e 是一个引用。u 和 v 分别是 ms 对应的成员的类型，只不过变成了const 的。

根据我们的推导，decltype(u) 是 const int，decltype(v) 是const std::string。


当声明对齐时也是类似：

```c++
alignas(16) auto [u, v] = ms; // 对 齐 匿 名 实 体， 而 不 是v

```
这里，我们对齐了匿名实体而不是 u 和v。这意味着 u 作为第一个成员会按照 16 字节对齐，但v 不会。

因此，即使使用了 auto 结构化绑定也不会发生类型退化 ([[decay]])

## [[move]]语义

## [[move语义 与 结构化绑定]]

后面还没看👇
[[888 - 具体略过了，以后再学]]