首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模型中的“同步”和“异步”是完全不同的概念。在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。

在并发模式中，**“同步”指的是程序完全按照代码序列的顺序执行；“异步”指的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。**

比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的读操作。

![[Pasted image 20220102040349.png]]


按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。

显然，异步线程的执行效率高，实时性强，这是很多嵌入式程序采用的模型。

但编写以异步方式执行的程序相对复杂，难于调试和扩展，而且不适合于大量的并发。

而同步线程则相反，它虽然效率相对较低，实时性较差，但逻辑简单。

因此，对于像服务器这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/半异步模式来实现。

半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。

异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。

请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。

具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。

比如最简单的轮流选取工作线程的[[round robin]]算法，也可以通过[[条件变量]]（见第14章）或[[信号量]]（见第14章）来随机地选择一个工作线程。图8-9总结了半同步/半异步模式的工作流程。

![[Pasted image 20220102050644.png]]


在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模型，则半同步/半异步模式就存在多种变体。其中有一种变体称为[[半同步 半反应堆模式]]（half-sync/half-reactive），如图8-10所示。


[[半同步 半反应堆模式]]
[[高效的半同步 半异步模式]]