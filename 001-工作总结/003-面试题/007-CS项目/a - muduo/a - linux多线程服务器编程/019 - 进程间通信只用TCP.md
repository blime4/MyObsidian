

Linux 下进程间通信（[[IPC]]）的方式数不胜数，光[UNPv2]列出的就有：匿名管道（pipe）、具名管道（FIFO）、POSIX 消息队列、共享内存、信号（signals）等等，更不必说 Sockets 了。同步原语（synchronization primitives）也很多，如互斥器（mutex）、条件变量（condition variable）、读写锁（reader-writer lock）、文件锁（record locking）、信号量（semaphore）等等。



在编程上，[[TCP sockets]] 和 [[pipe]] 都是[[操作文件描述符]]，用来收发字节流，都可以 read/write/fcntl/select/poll 等。不同的是，TCP 是双向的，Linux 的 pipe 是单向的，进程间双向通信还得开两个文件描述符，不方便；而且进程要有父子关系才能用 pipe，这些都限制了 pipe 的使用。在收发字节流这一通信模型下，没有比 Sockets/TCP 更自然的 IPC 了。

TCP port 由一个进程独占，且操作系统会自动回收（listening port 和已建立连接的 TCP socket 都是文件描述符，在进程结束时操作系统会关闭所有文件描述符）。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后能比较容易地恢复，而不需要重启操作系统（用跨进程的 mutex 就有这个风险）。
