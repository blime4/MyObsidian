---
doc_type: weread-highlights-reviews
bookId: "37669248"
author: 王利涛编著
cover: https://cdn.weread.qq.com/weread/cover/41/YueWen_37669248/t7_YueWen_37669248.jpg
reviewCount: 0
noteCount: 26
readingStatus: 在读
progress: 92%
totalReadDay: 19
readingTime: 11小时41分钟
readingDate: 2021-12-20
isbn: 9787121408564
lastReadDate: 2023-10-18

---
# 元数据
> [!abstract] 嵌入式C语言自我修养：从芯片、编译器到操作系统
> - ![ 嵌入式C语言自我修养：从芯片、编译器到操作系统|200](https://cdn.weread.qq.com/weread/cover/41/YueWen_37669248/t7_YueWen_37669248.jpg)
> - 书名： 嵌入式C语言自我修养：从芯片、编译器到操作系统
> - 作者： 王利涛编著
> - 简介： 这是一本专门为嵌入式读者打造的C语言进阶学习图书。本书的学习重点不再是C语言的基本语法，而是和嵌入式、C语言相关的一系列知识。作者以C语言为切入点，分别探讨了嵌入式开发所需要的诸多核心理论和技能，力图帮助读者从零搭建嵌入式开发所需要的完整知识体系和技能树。本书从底层CPU的制造流程和工作原理开始讲起，到计算机体系结构，C程序的反汇编分析，程序的编译、运行和重定位，程序运行时的堆栈内存动态变化，GNU C编译器的扩展语法，指针的灵活使用，C语言的面向对象编程思想，C语言的模块化编程思想，C语言的多任务编程思想，进程、线程和协程的概念，从底层到上层，从芯片、硬件到软件、框架，几乎涵盖了嵌入式开发的所有知识点。
> - 出版时间 2021-04-01 00:00:00
> - ISBN： 9787121408564
> - 分类： 计算机-理论知识
> - 出版社： 电子工业出版社
> - PC地址：https://weread.qq.com/web/reader/e9e326b0723ec980e9e9dfd

# 高亮划线

### 2.1 一颗芯片是怎样诞生的

> 📌 一个原子由质子、中子和核外电子组成。中子不带电，质子带正电，核外电子带负电，整个原子显中性。根据电子的能级分布，一个原子的最外层电子数为8时最稳定。如钠原子，核外电子层分布为2—8—1，最外层1个电子，能量最大、受原子核的约束力小，所以最不稳定，受到激发容易发生跃迁，脱离钠原子，成为自由移动的电子。这些自由移动的电子在电场的作用下，会发生定向移动形成电流，这就是金属导电的原理。很多金属原子的最外层电子数小于4，容易丢失电子，称为自由移动的电子，所以金属容易导电，是导体。而对于氯原子，最外层有7个电子，倾向于从别处捕获一个电子，形成最外层8个电子的稳定结构，氯原子因为不能产生自由移动的电子，所以不能导电，是绝缘体。 
> ⏱ 2023-08-29 13:23:31 ^37669248-12-3178-3488

### 2.2 一颗CPU是怎么设计出来的

> 📌 任何复杂的运算都可以分解为有限个基本运算指令。 
> ⏱ 2023-08-29 14:03:32 ^37669248-13-968-991

### 2.4 CPU性能提升：Cache机制

> 📌 有速度瓶颈的地方就有缓存，这种思想在计算机中随处可见。 
> ⏱ 2023-08-29 20:30:13 ^37669248-15-802-829

> 📌 元器件的运行速度总是和电路成本成正比。 
> ⏱ 2023-08-29 20:32:46 ^37669248-15-2795-2814

> 📌 使用Cache无法保证实时性。当缓存未命中时，CPU从RAM中读取数据的时间是不确定的，这是嵌入式实时控制场景无法接受的。因此，在一些面向嵌入式工业控制、实时领域、超低功耗的处理器中，大家可以看到很多没有集成Cache的处理器。不要觉得奇怪：适合自己的，才是最好的，不是所有的牛奶都叫特仑苏，不是所有的处理器都需要Cache。 
> ⏱ 2023-08-29 20:34:41 ^37669248-15-4303-4466

### 3.4 ARM伪指令

> 📌 NOP伪指令比较简单，其实就相当于MOV R0，R0。在以后的学习和工作中，大家在ARM汇编程序中经常看到的就是LDR伪指令。 
> ⏱ 2023-09-02 22:30:06 ^37669248-25-865-928

> 📌 RISC指令的特点是单周期指令，指令的长度一般都是固定的。在一个32位的系统中，一条指令通常是32位的，指令中包括操作码和操作数， 
> ⏱ 2023-09-03 11:06:24 ^37669248-25-1538-1603

> 📌 LDR不是普通的ARM加载指令，而是一个伪指令。为了与ARM指令集中的加载指令LDR区别开来，LDR伪指令中的操作数前一般会有一个等于号=，用来表示该指令是个伪指令 
> ⏱ 2023-09-03 11:07:47 ^37669248-25-2193-2275

### 3.5 ARM汇编程序设计

> 📌 在上面的汇编程序中，我们实现了一个汇编子程序SUM_ASM，使用EXPORT伪操作将其声明为一个全局符号，然后其他汇编程序或C程序就可以直接调用它了。
SUM_ASM汇编子程序自身又调用了其他子程序sum，这个sum子程序可以是一个汇编子程序，也可以是一个使用C语言定义的函数。在调用之前我们要先使用IMPORT伪操作把sum子程序导入进来，然后就可以直接使用BL指令跳转过去运行了。只要遵循一些约定的规则，C程序和汇编程序其实是可以相互调用的，从汇编指令的层面上看，它们之间并无本质的区别。 
> ⏱ 2023-09-03 23:28:04 ^37669248-26-4467-4725

### 3.6 C语言和汇编语言混合编程

> 📌 ATPCS的全称是ARM-Thumb Procedure Call Standard，其核心内容就是定义了ARM子程序调用的基本规则及堆栈的使用约定等。 
> ⏱ 2023-09-03 23:39:08 ^37669248-27-1085-1161

### 4.1 从源程序到二进制文件

> 📌 在Shell终端下用你修长的手指敲入readelf命令，将会看到如下信息。 
> ⏱ 2023-09-04 09:25:54 ^37669248-30-1765-1802

> 📌 BSS段比较特殊，一般来讲，未初始化的全局变量和静态变量会放置在BSS段中，但是因为它们未初始化，默认值全部是0，其实没有必要再单独开辟空间存储，为了节省存储空间，所以在可执行文件中BSS段是不占用空间的。 
> ⏱ 2023-09-04 09:28:10 ^37669248-30-3463-3566

> 📌 如果程序在编译时设置为debug模式，则可执行文件中还会有一个专门的.debug section，用来保存可执行文件中每一条二进制指令对应的源码位置信息。根据这些信息，GDB调试器就可以支持源码级的单步调试，否则你单步执行的都是二进制指令，可读性不高，不方便调试。 
> ⏱ 2023-09-04 09:28:55 ^37669248-30-3837-3969

### 4.3 程序的编译

> 📌 汇编器的主要工作就是参考ISA指令集，将汇编代码翻译成对应的二进制指令，同时生成一些必要的信息，以section的形式组装到目标文件中，后面的链接过程会用到这些信息。 
> ⏱ 2023-09-04 22:07:53 ^37669248-32-4462-4545

### 4.4 链接过程

> 📌 链接主要分为3个过程：分段组装、符号决议和重定位。 
> ⏱ 2023-09-11 17:36:15 ^37669248-33-985-1010

> 📌 编译器为了解决这种符号冲突，引入了强符号和弱符号的概念：函数名、初始化的全局变量是强符号，而未初始化的全局变量则是弱符号。有了强符号和弱符号的概念后，再理解上面的三句话就比较清晰了：在一个多文件的工程中，强符号不允许多次定义，否则就会发生重定义错误。强符号和弱符号可以在一个项目中共存，当强弱符号共存时，强符号会覆盖掉弱符号，链接器会选择强符号作为可执行文件中的最终符号。 
> ⏱ 2023-09-11 17:43:31 ^37669248-33-5190-5376

> 📌 链接器也允许一个项目中出现多个弱符号共存。 
> ⏱ 2023-09-11 17:46:18 ^37669248-33-5965-5986

> 📌 在程序编译期间，编译器在分析每个文件中未初始化的全局变量时，并不知道该符号在链接阶段是被采用还是被丢弃，因此在程序编译期间，未初始化的全局变量并没有被直接放置在BSS段中，而是将这些弱符号放到一个叫作COMMON的临时块中，在符号表中使用一个未定义的COMMON来标记，在目标文件中也没有给它们分配存储空间。 
> ⏱ 2023-09-11 17:46:34 ^37669248-33-5986-6140

> 📌 GNU C编译器在ANSI C语法标准的基础上扩展了一系列C语言语法，如提供了一个__attribute__关键字用来声明符号的属性。通过下面的命令，可以将一个强符号转化为弱符号。 
> ⏱ 2023-09-11 17:48:03 ^37669248-33-7000-7090

### 4.8 动态链接

> 📌 实现PIC需要底层相关的技术支撑，不同的平台有不同的实现方式。实现代码与地址无关，在模块内部，对函数和全局变量的引用要避免使用绝对地址，一般可以使用相对跳转代替。 
> ⏱ 2023-09-12 11:53:34 ^37669248-37-3899-3980

> 📌 当程序运行时，动态链接器首先被加载到内存运行，动态链接器会分析可执行文件，从可执行文件的.dynamic段中查询该程序运行需要依赖的动态共享库，然后到库的默认路径下查找这些共享库，加载到内存中并进行动态链接，链接成功后将CPU的控制权交给可执行程序，我们的程序就可以正常运行了。 
> ⏱ 2023-09-12 12:00:05 ^37669248-37-8565-8704

### 4.10 Linux内核模块运行机制

> 📌 hello.ko和动态库的不同之处在于：一个运行在内核空间，一个运行在用户空间。 
> ⏱ 2023-09-12 12:11:37 ^37669248-39-1966-2006

### 5.2 Linux环境下的内存管理

> 📌 现在很多高端的SoC芯片，随着集成的IP模块越来越多，导致Linux内核镜像运行时需要的地址空间也越来越大。在很多处理器平台下，大家也经常看到如图5-3所示的划分：0～2GB的地址空间为用户空间，2～4GB的地址空间为内核空间。所有用户进程共享内核地址空间，但独享各自的用户地址空间。 
> ⏱ 2023-09-21 11:09:00 ^37669248-45-1125-1267

### 5.4 堆内存管理

> 📌 堆内存是匿名的，不能像变量那样使用名字直接访问，一般通过指针间接访问。 
> ⏱ 2023-10-18 13:40:35 ^37669248-47-2211-2246

### 5.6 内存泄漏与防范

> 📌 为了避免fast bins带来的内存碎片化，用户可根据自己的实际业务需求，将参数M_MXFAST设置为0，关闭fast bins功能。 
> ⏱ 2023-10-18 17:13:54 ^37669248-49-7512-7579

### 5.7 常见的内存错误及检测

> 📌 以Valgrind为例，不仅可以检测内存泄漏，还可以对程序进行各种性能分析、代码覆盖测试、堆栈分析及CPU的Cache命中率、丢失率分析等。这么好的工具，此时不用，更待何时？ 
> ⏱ 2023-10-18 17:36:04 ^37669248-50-7570-7657

# 读书笔记

# 本书评论
