# 内联变量产生的动机


在C++里不允许在类里初始化非常量静态成员：
```c++
	class MyClass {
	static std::string msg{"OK"};
	// 编 译 期ERROR
	...
	};
```


可以在类定义的外部定义并初始化非常量静态成员，但如果被多个 CPP 文件同时包含的话又会引发新的错误：
```c++
	class MyClass {
	static std::string msg;
	...
	};
	std::string MyClass::msg{"OK"}; // 如 果 被 多 个CPP文 件 包 含 会 导 致 链 接ERROR
```
根据[[一次定义原则]] (ODR)，一个变量或实体的定义只能出现在一个翻译单元内——除非该变量或实体被定义为inline 的。

即使使用预处理来进行保护也没有用：
```c++
#ifndef MYHEADER_HPP

#define MYHEADER_HPP

class MyClass {

static std::string msg;

...

};

std::string MyClass::msg{"OK"}; // 如 果 被 多 个CPP文 件 包 含 会 导 致 链 接ERROR

#endif
```
![[Pasted image 20220114035249.png]]

### 解决方法
![[Pasted image 20220114035512.png]]

![[Pasted image 20220114035652.png]]

![[Pasted image 20220114035754.png]]

+ 然而，所有这些方法都会导致签名重载，可读性也会变差，使用该变量的方式也变得不同。
+ 另外，全局变量的初始化可能会推迟到第一次使用时。
+ 所以那些假设变量一开始就已经初始化的写法是不可行的（例如使用一个对象来监控整个程序的过程）。