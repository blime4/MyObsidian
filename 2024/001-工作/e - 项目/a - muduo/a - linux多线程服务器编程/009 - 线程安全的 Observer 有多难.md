

**一个动态创建的对象是否还活着，光看指针是看不出来的（引用也一样看不出来）。指针就是指向了一块内存，这块内存上的对象如果已经销毁，那么就根本不能访问。**

 （就像 free (3) 之后的地址不能访问一样），==既然不能访问又如何知道对象的状态呢？==换句话说，**判断一个指针是不是合法指针没有高效的办法，这是 C/C++指针问题的根源**
 
 
 在面向对象程序设计中，对象的关系主要有三种：[[composition]]、[[aggregation]]、[[association]]。composition（组合／复合）关系在多线程里不会遇到什么麻烦，因为对象x的生命期由其唯一的拥有者owner控制，owner析构的时候会把x也析构掉。从形式上看，x是owner的直接数据成员，或者scoped_ptr成员，抑或owner持有的容器的元素。
后两种关系在C++里比较难办，处理不好就会造成内存泄漏或重复释放。association（关联／联系）是一种很宽泛的关系，它表示一个对象a用到了另一个对象b，调用了后者的成员函数。从代码形式上看，==a持有b的指针（或引用），但是b的生命期不由a单独控制。==aggregation（聚合）关系从形式上看与association相同，除了a和b有逻辑上的整体与部分关系。如果b是动态创建的并在整个程序结束前有可能被释放，那么就会出现§1.1谈到的竞态条件。


那么似乎一个简单的解决办法是：只创建不销毁。程序使用一个[[对象池]]来暂存用过的对象，下次申请新对象时，如果对象池里有存货，就重复利用现有的对象，否则就新建一个。对象用完了，不是直接释放掉，而是放回池子里。这个办法当然有其自身的很多缺点，但至少能避免访问失效对象的情况发生。


[[对象池的问题]]
