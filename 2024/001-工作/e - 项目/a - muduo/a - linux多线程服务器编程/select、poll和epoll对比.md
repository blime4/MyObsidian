# select、poll和epoll对比

## 原理
### [[select]]
select本质上是通过设置或者检査存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
1. 单个进程可监视的fd数量被限制
2. 需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大
3. 对 socket进行扫描时是线性扫描
### [[poll]]
poll本质上和 select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历它没有最大连接数的限制，原因是它是**基于链表来存储**的，但是同样有一个缺点：
大量的和fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义poll还有一个特点是“[[水平触发]]”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。
### [[epoll]]
在前面说到的复制问題上，epoll使用[[mmap]]减少复制开销还有一个特点是，epo使用“事件”的就绪通知方式，通过 epoll_tl注册fd，一旦该fd就绪内核就会采用类似 callback的回调机制来激活该和， epoll_wait便可以收到通知


## 一个进程所能打开的最大连接数
+ select
	+ 单个进程所能打开的最大连接数有 FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32* 32，同理64位机器上 FD_SETSIZE为32* 64），当然我们可以对进行修改然后重新编译内核，但是性能可能会受到影响，这需要进一步的测
+ poll
	+ poll本质上和 select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
+ epoll
	+ 没有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接


## FD剧增后带来的IO效率问题
+ select 
	+ 因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题"
+ poll
	+ 同上
+ epoll
	+ 因为epoll内核中实现是根据每个fd上的 callback函数来实现的，只有活跃的 socket才会主动调用 callback所以在活跃 socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有 socket都很活跃的情况下，可能会有性能问题。


## 消息传递方式
+ select
	+ 内核需要将消息传递到用户空间，都需要內核拷贝动作
+ poll
	+ 同上
+ epoll
	+ epoll通过内核和用户空间共享一块内存来实现的。