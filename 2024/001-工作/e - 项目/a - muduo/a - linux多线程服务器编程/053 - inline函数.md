# 053 - inline 函数


由于 inline 函数的关系，C++源代码里调用一个函数并不意味着生成的目标代码里也会做一次真正的函数调用（可能看不到 call 指令）。

现在的编译器聪明到可以自动判断一个函数是否适合 inline，因此 inline 关键字在源文件中往往不是必需的。

当然，在头文件里 inline 还是要的，为了防止链接器抱怨[[重复定义]]（multiple definition）。

---

现在的 C++编译器采用[[重复代码消除]]  的办法来避免重复定义。也就是说，如果编译器无法 inline 展开的话，每个编译单元都会生成 inline 函数的目标代码，然后链接器会从多份实现中任选一份保留，其余的则丢弃（vague linkage）。

如果编译器能够展开 inline 函数，那就不必单独为之生成目标代码了（除非使用函数指针指向它）。

---

## 编译器层面
> 编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码，所以当你 inline 某个函数，或许编译器就因此有能力对它（函数本体）执行语境相关 `最优化`。大部分编译器绝不会对着一个“outlined 函数调用”动作执行如此之最优化。

---


## 其他内置函数

除了inline函数，g++还有大量的内置函数（built-in function），因此源代码中出现memcpy、memset、strlen、sin、exp之类的“函数调用”不一定真的会调用libc里的库函数。另外，由于编译器知道这些函数的功能，因此优化起来更充分。

---

## Inline 函数可能带来的问题

inline 函数背后的整体观念是，将“对此函数的每一个调用”都以函数本体替换之。我想不需要统计学博士来告诉你，这样做可能增加你的[[目标码]]（object code）大小。在一台内存有限的机器上，过度热衷 inlining 会造成程序体积太大（对可用空间而言）。即使拥有虚内存，inline 造成的代码膨胀亦会导致额外的 `换页行为（paging）`，降低指令 ` 高速缓存装置的击中率` （instruction cache hit rate），以及伴随这些而来的效率损失。

[[换页]]
[[指令击中率]]

---

## Inline的时机
Inline 函数 `通常` 一定被置于头文件内，因为大多数建置环境（build environments）在编译过程中进行 inlining，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。

---

## Inline与Template
Template 的具现化与 inlining 无关。如果你正在写一个 template 而你认为==所有==根据此 template 具现出来的函数都应该 inlined，请将此 template 声明为 inline。
==否则，请不要将 Template声明为inline==

[[055 - Inline与Template]]

---

## Inline与虚函数

大部分编译器拒绝将太过复杂（例如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使inlining 落空。这不该令你惊讶，因为virtual意味“等待，直到运行期才确定调用哪个函数”，而 inline意味“执行前，先将调用动作替换为被调用函数的本体”。如果编译器不知道该调用哪个函数，你就很难责备它们拒绝将函数本体inlining。
> virtual ----- 运行时
> inline  ----- 执行前替换

---

## inline 不成功的例子

有时候虽然编译器有意愿 inlining 某个函数，还是可能为该函数生成一个函数本体。
+ `取地址` ： 如果程序要取某个 inline 函数的地址，编译器通常必须为此函数生成一个 outlined 函数本体。毕竟编译器哪有能力提出一个指针指向并不存在的函数呢？
+ `函数指针` : 与此并提的是，编译器通常不对“通过[[函数指针]]而进行的调用”实施 inlining，这意味对 inline 函数的调用有可能被 inlined，也可能不被 inlined，取决于该调用的实施方式：

---

## 不要在构造函数和析构函数中使用inline

C++对于“对象被创建和被销毁时发生什么事”做了各式各样的保证。当你使用 new，动态创建的对象被其构造函数自动初始化；当你使用 delete，对应的析构函数会被调用。当你创建一个对象，其每一个 base class 及每一个成员变量都会被自动构造；当你销毁一个对象，反向程序的析构行为亦会自动发生。如果有个异常在对象构造期间被抛出，该对象已构造好的那一部分会被自动销毁。

---

在这些情况中 C++描述了什么一定会发生，但没有说如何发生。“事情如何发生”是编译器实现者的权责，不过至少有一点很清楚，那就是它们不可能凭空发生。你的程序内一定有某些代码让那些事情发生，而那些代码——由编译器于编译期间代为产生并安插到你的程序中的代码——肯定存在于某个地方。有时候就放在你的构造函数和析构函数内

---

## inline与[[052 - 二进制兼容性]]

程序库设计者必须评估“将函数声明为inline”的冲击：inline函数无法随着程序库的升级而升级。换句话说如果 f是程序库内的一个inline函数，客户将“f函数本体”编进其程序中，一旦程序库设计者决定改变f，所有用到f的客户端程序都必须重新编译。这往往是大家不愿意见到的。

---

然而如果f是non-inline函数，一旦它有任何修改，客户端只需重新连接就好，远比重新编译的负担少很多。如果程序库采取动态连接，升级版函数甚至可以不知不觉地被应用程序吸纳。

---

## inline与调试

大部分调试器面对 inline 函数都束手无策。这对你应该不是太大的意外，毕竟你如何在一个并不存在的函数内设立断点（breakpoint）呢？虽然某些建置环境勉力支持对 inlined函数的调试，其他许多建置环境仅仅只能“在调试版程序中禁止发生inlining”。

---

## 请记住

■ 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。

■ 不要只因为function templates出现在头文件，就将它们声明为inline。



