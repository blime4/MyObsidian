---
doc_type: weread-highlights-reviews
bookId: "622000"
author: 黄健宏
cover: https://cdn.weread.qq.com/weread/cover/54/YueWen_622000/t7_YueWen_622000.jpg
reviewCount: 0
noteCount: 36
readingStatus: 在读
progress: 37%
totalReadDay: 5
readingTime: 14小时18分钟
readingDate: 2021-11-11
isbn: 9787111464747
lastReadDate: 2021-11-14

---
# 元数据
> [!abstract] Redis设计与实现
> - ![ Redis设计与实现|200](https://cdn.weread.qq.com/weread/cover/54/YueWen_622000/t7_YueWen_622000.jpg)
> - 书名： Redis设计与实现
> - 作者： 黄健宏
> - 简介： 《Redis设计与实现》对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，这些知识可以帮助读者更好、更高效地使用Redis。本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制（replication）、集群（cluster）三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。
> - 出版时间 2015-01-01 00:00:00
> - ISBN： 9787111464747
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/d35323e0597db0d35bd957b

# 高亮划线

#### 8.2 字符串对象

> 📌 另外，因为Redis没有为embstr编码的字符串对象编写任何相应的修改程序（只有int编码的字符串对象和raw编码的字符串对象有这些程序），所以embstr编码的字符串对象实际上是只读的。当我们对embstr编码的字符串对象执行任何修改命令时，程序会先将对象的编码从embstr转换成raw，然后再执行修改命令。 
> ⏱ 2021-11-12 17:14:25 ^622000-49-4540-4697

#### 8.6 有序集合对象

> 📌 虽然zset结构同时使用跳跃表和字典来保存有序集合元素，但这两种数据结构都会通过指针来共享相同元素的成员和分值，所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值，也不会因此而浪费额外的内存。 
> ⏱ 2021-11-12 19:01:55 ^622000-53-2060-2164

> 📌 在理论上，有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现，但无论单独使用字典还是跳跃表，在性能上对比起同时使用字典和跳跃表都会有所降低。举个例子，如果我们只使用字典来实现有序集合，那么虽然以O（1）复杂度查找成员的分值这一特性会被保留，但是，因为字典以无序的方式来保存集合元素，所以每次在执行范围型操作——比如ZRANK、ZRANGE等命令时，程序都需要对字典保存的所有元素进行排序，完成这种排序需要至少O（NlogN）时间复杂度，以及额外的O（N）内存空间（因为要创建一个数组来保存排序后的元素）。 
> ⏱ 2021-11-12 19:02:17 ^622000-53-2275-2531

> 📌 另一方面，如果我们只使用跳跃表来实现有序集合，那么跳跃表执行范围型操作的所有优点都会被保留，但因为没有了字典，所以根据成员查找分值这一操作的复杂度将从O（1）上升为O（logN）。因为以上原因，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis选择了同时使用字典和跳跃表两种数据结构来实现有序集合。 
> ⏱ 2021-11-12 19:02:45 ^622000-53-2564-2718

> 📌 为了展示方便，图8-17在字典和跳跃表中重复展示了各个元素的成员和分值，但在实际中，字典和跳跃表会共享元素的成员和分值，所以并不会造成任何数据重复，也不会因此而浪费任何内存。 
> ⏱ 2021-11-12 19:03:05 ^622000-53-3466-3553

#### 8.7 类型检查与命令多态

> 📌 从上面发生类型错误的代码示例可以看出，为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。 
> ⏱ 2021-11-12 19:08:21 ^622000-54-1706-1799

#### 8.9 对象共享

> 📌 目前来说，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。 
> ⏱ 2021-11-12 19:20:44 ^622000-56-1683-1782

#### 9.2 切换数据库

> 📌 通过修改redisClient.db指针，让它指向服务器中的不同数据库，从而实现切换目标数据库的功能——这就是SELECT命令的实现原理。 
> ⏱ 2021-11-12 22:37:40 ^622000-62-1862-1931

> 📌 在执行Redis命令特别是像FLUSHDB这样的危险命令之前，最好先执行一个SELECT命令，显式地切换到指定的数据库，然后才执行别的命令。 
> ⏱ 2021-11-12 22:38:09 ^622000-62-2319-2389

#### 9.5 过期键删除策略

> 📌 除此之外，创建一个定时器需要用到Redis服务器中的时间事件，而当前时间事件的实现方式——无序链表，查找一个事件的时间复杂度为O（N）——并不能高效地处理大量时间事件。因此，要让服务器创建大量的定时器，从而实现定时删除策略，在现阶段来说并不现实。 
> ⏱ 2021-11-13 21:04:51 ^622000-65-1369-1521

#### 9.6 Redis的过期键删除策略

> 📌 定时删除、惰性删除和定期删除三种过期键删除策略 
> ⏱ 2021-11-14 00:37:20 ^622000-66-442-465

> 📌 Redis服务器实际使用的是惰性删除和定期删除两种策略：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。 
> ⏱ 2021-11-14 00:37:22 ^622000-66-466-542

> 📌 activeExpireCycle函数就会被调用，它在规定的时间内，分多次遍历服务器中的各个数据库，从数据库的expires字典中随机检查一部分键的过期时间，并删除其中的过期键。 
> ⏱ 2021-11-14 16:54:55 ^622000-66-2121-2210

> 📌 activeExpireCycle函数的工作模式可以总结如下：❑函数每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。❑全局变量current_db会记录当前activeExpireCycle函数检查的进度，并在下一次activeExpireCycle函数调用时，接着上一次的进度进行处理。比如说，如果当前activeExpireCycle函数在遍历10号数据库时返回了，那么下次activeExpireCycle函数执行时，将从11号数据库开始查找并删除过期键。❑随着activeExpireCycle函数的不断执行，服务器中的所有数据库都会被检查一遍，这时函数将current_db变量重置为0，然后再次开始新一轮的检查工作。 
> ⏱ 2021-11-14 16:55:20 ^622000-66-3419-3841

#### 9.7 AOF、RDB和复制功能对过期键的处理

> 📌 在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。 
> ⏱ 2021-11-14 16:55:43 ^622000-67-603-672

> 📌 ❑如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。 
> ⏱ 2021-11-14 16:56:03 ^622000-67-1016-1110

> 📌 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。 
> ⏱ 2021-11-14 16:59:14 ^622000-67-1141-1196

> 📌 因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。 
> ⏱ 2021-11-14 16:59:21 ^622000-67-1199-1262

> 📌 举个例子，如果数据库中包含三个键k1、k2、k3，并且k2已经过期，那么当服务器启动时：❑如果服务器以主服务器模式运行，那么程序只会将k1和k3载入到数据库，k2会被忽略。❑如果服务器以从服务器模式运行，那么k1、k2和k3都会被载入到数据库。 
> ⏱ 2021-11-14 16:59:37 ^622000-67-1291-1473

> 📌 当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。 
> ⏱ 2021-11-14 18:46:34 ^622000-67-1669-1727

> 📌 和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查， 
> ⏱ 2021-11-14 18:47:28 ^622000-67-2056-2096

> 📌 数据库中包含过期键不会对AOF重写造成影响。 
> ⏱ 2021-11-14 18:47:22 ^622000-67-2248-2270

> 📌 当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制： 
> ⏱ 2021-11-14 18:48:44 ^622000-67-2359-2393

> 📌 ❑从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。❑从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。 
> ⏱ 2021-11-14 18:49:35 ^622000-67-2504-2624

> 📌 当一个过期键仍然存在于主服务器的数据库时，这个过期键在从服务器里的复制品也会继续存在。 
> ⏱ 2021-11-14 18:50:00 ^622000-67-2702-2745

#### 9.8 数据库通知

> 📌 关注“某个键执行了什么命令”的通知称为键空间通知（key-space notification），除此之外，还有另一类称为键事件通知（key-event notification）的通知，它们关注的是“某个命令被什么键执行了”。 
> ⏱ 2021-11-14 18:56:32 ^622000-68-1070-1184

#### 9.9 重点回顾

> 📌 ❑Redis服务器的所有数据库都保存在redisServer.db数组中，而数据库的数量则由redisServer.dbnum属性保存。 
> ⏱ 2021-11-14 19:02:49 ^622000-69-424-492

> 📌 ❑数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。 
> ⏱ 2021-11-14 19:03:08 ^622000-69-604-668

> 📌 ❑数据库的键总是一个字符串对象，而值则可以是任意一种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。 
> ⏱ 2021-11-14 19:03:54 ^622000-69-762-857

> 📌 ❑从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。 
> ⏱ 2021-11-14 19:08:34 ^622000-69-1373-1444

#### 10.1 RDB文件的创建与载入

> 📌 和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求： 
> ⏱ 2021-11-14 19:12:52 ^622000-71-643-718

> 📌 另外值得一提的是，因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：❑如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。❑只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态 
> ⏱ 2021-11-14 19:15:08 ^622000-71-1820-2001

> 📌 最后，BGREWRITEAOF和BGSAVE两个命令不能同时执行： 
> ⏱ 2021-11-14 19:17:34 ^622000-71-3379-3412

#### 10.2 自动间隔性保存

> 📌 Redis的服务器周期性操作函数serverCron默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是检查save选项所设置的保存条件是否已经满足，如果满足的话，就执行BGSAVE命令。 
> ⏱ 2021-11-14 19:40:53 ^622000-72-4153-4266

#### 10.3 RDB文件结构

> 📌 6.INTSET编码的集合如果TYPE的值为REDIS_RDB_TYPE_SET_INTSET，那么value保存的就是一个整数集合对象，RDB文件保存这种对象的方法是，先将整数集合转换为字符串对象，然后将这个字符串对象保存到RDB文件里面。如果程序在读入RDB文件的过程中，碰到由整数集合对象转换成的字符串对象，那么程序会根据TYPE值的指示，先读入字符串对象，再将这个字符串对象转换成原来的整数集合对象。 
> ⏱ 2021-11-14 22:24:00 ^622000-73-16566-16835

### 第11章 AOF持久化

> 📌 与RDB持久化通过保存数据库中的键值对来记录数据库状态不同，AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态的 
> ⏱ 2021-11-14 22:55:53 ^622000-77-474-539

# 读书笔记

# 本书评论
