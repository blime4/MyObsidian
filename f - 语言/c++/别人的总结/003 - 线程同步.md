# 003 - 线程同步


[[互斥锁]]
```c++
std::mutex mu;
mu.lock();
if ((i % interval) == 0)
{
	myList.push_back(i);
}
mu.unlock();
```

## std::[[lock_guard]]
C++11 提供了类似于 muduo 的 [[MutexLockGuard]] 的 std :: lock_guard 来方便使用互斥锁，作用域区间内一旦结束便自动 unlock，内部猜想也是使用了 [[RAII]] 设计的：
```c++
std::mutex myMutex;
std::lock_guard<std::mutex> guard(myMutex);
for (int i = 0; i < max; i++) {
	if ((i % interval) == 0) myList.push_back(i);
}
```

## [[unique_lock]]
临时解锁
```c++
std::mutex _mu;
std::unique_lock<std::mutex> guard(_mu);
//do something 1
guard.unlock(); //临时解锁
//do something 2
guard.lock(); //继续上锁
// do something 3
```
这样使用起来就比 lock_guard 更加灵活！然后这也是有代价的，因为**它内部需要维护锁的状态，所以效率要比 lock_guard 低**一点，在 lock_guard 能解决问题的时候，就是用 lock_guard，反之，使用 unique_lock。

另外，请注意，**unique_lock 和 lock_guard 都不能复制，lock_guard 不能移动，但是 unique_lock 可以**：
```c++
// unique_lock 可以移动，不能复制
std::unique_lock<std::mutex> guard1(_mu);
std::unique_lock<std::mutex> guard2 = guard1;  // error
std::unique_lock<std::mutex> guard2 = std::move(guard1); // ok

// lock_guard 不能移动，不能复制
std::lock_guard<std::mutex> guard1(_mu);
std::lock_guard<std::mutex> guard2 = guard1;  // error
std::lock_guard<std::mutex> guard2 = std::move(guard1); // error
```

### [[条件变量]]

#include <condition_variable>头文件主要包含有类和函数相关的条件变量。

包括相关类 std :: [[004 - condition_variable]] 和 std :: [[condition_variable_any]]，还有枚举类型 std :: [[cv_status]]。另外还包含函数 std :: notify_all_at_thread_exit ()，以下分别介绍一下以上几种类型。

