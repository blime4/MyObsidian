

# 4. C++11：感觉像是门新语言


[[C++11]] 引入了大量令人眼花缭乱的[[语言特性]]，包括：

- [[内存模型]]——一个高效的为现代硬件设计的底层抽象，作为描述并发的基础
- [[auto]] 和 [[decltype]]——避免类型名称的不必要重复
- [[范围 for]]——对范围的简单顺序遍历
- [[移动语义]]和[[右值引用]]——减少数据拷贝
- [[统一初始化]]—— 对所有类型都（几乎）完全一致的初始化语法和语义
- [[nullptr]]——给空指针一个名字
- [[constexpr]] 函数——在编译期进行求值的函数
- [[用户定义字面量]]——为用户自定义类型提供字面量支持
- [[原始字符串字面量]]——不需要转义字符的字面量，主要用在[[正则表达式]]中
- [[属性]]——将任意信息同一个名字关联
- [[lambda 表达式]]——[[匿名函数对象]]
- [[变参模板]]——可以处理任意个任意类型的参数的模板
- [[模板别名]]——能够重命名模板并为新名称绑定一些模板参数
- [[noexcept]]——确保函数不会抛出异常的方法
- [[override]] 和 [[final]]——用于管理大型类层次结构的明确语法
- [[static_assert]]——[[编译期断言]]
- [[long long]]——更长的整数类型
- [[默认成员初始化器]]——给数据成员一个默认值，这个默认值可以被构造函数中的初始化所取代
- [[enum class]]——枚举值带有作用域的[[强类型枚举]]

以下是主要的标准库组件列表

- [[unique_ptr]] 和 [[shared_ptr]]——依赖 [[RAII]]的[[资源管理指针]]
- [[内存模型]]和 [[atomic]] 变量
- [[thread]]、[[mutex]]、[[condition_variable]] 等——为基本的系统层级的并发提供了[[类型安全]]、可移植的支持
- [[future]]、[[promise]] 和 [[packaged_task]]，等——稍稍更高级的并发
- [[tuple]]——匿名的简单复合类型
- [[类型特征]]（[[type trait]]）——类型的可测试属性，用于[[元编程]]
- [[正则表达式匹配]]（[§4.6](#46-c11标准库组件)）
- [[随机数]]——带有许多生成器（引擎）和多种分布
- [[时间]]——[[time_point]] 和 [[duration]]
- [[unordered_map]] 等——[[哈希表]]
- [[forward_list]]——[[单向链表]]
- [[array]]——具有固定常量大小的数组，并且会记住自己的大小
- [[emplace运算]]——在容器内直接构建对象，避免拷贝
- [[exception_ptr]]——允许在线程之间传递异常




## 4.1 C++11：并发支持

### 4.1.1 [[内存模型]]
### 4.1.2 [[线程和锁]]
### 4.1.3 [[期值]]

此外，[[并行算法]]、[[网络]]和[[协程]]是单独分组处理的，并且（正如预期）还没法用于 C++11。

## 4.2 C++11：简化使用

### 4.2.1 `auto` 和 `decltype`
### 4.2.2 [[范围 for]]
### 4.2.3 [[移动语义]]
### 4.2.4 资源管理指针

C++11 提供了“智能指针”（[§4.2.4](#424-资源管理指针)）：

- `shared_ptr`——代表共享所有权
- `unique_ptr`——代表独占所有权（取代 C++98 中的 `auto_ptr`）

添加这些表示所有权的资源管理“智能指针”对编程风格有很大的影响。对很多人来说，这意味着不再有资源泄漏，悬空指针的问题也显著减少。在自动化资源管理和减少裸指针使用的努力中，它们是最明显的部分了（[§4.2.3](#423-移动语义)）。

`shared_ptr` 是传统的计数指针：指向同一对象的所有指针共享一个计数器。当最后一个指向对象的共享指针被销毁时，被指向的对象也会被销毁。这是一种简单、通用且有效的垃圾收集形式。它能正确地处理非内存资源（[§2.2.1](02%20-%20背景：C++%20的%201979–2006.md#221-语言特性)）。为了正确处理环形数据结构，还需要有 `weak_ptr`；不过，这往往不是最好的做法。人们常常简单地使用 `shared_ptr` 来安全地从工厂函数返回数据：

```cpp
shared_ptr<Blob> make_Blob(Args a)
{
    auto p = shared_ptr<Blob>(new Blob(a));
    // ... 把很多好东西填到 *p ...
    return p;
}
```

当把对象移出函数时，引用计数会从 1 变到 2 再变回 1。在多线程程序中，这通常是涉及到同步的缓慢操作。另外，粗率地使用和/或实现引用计数，会增加分配和回收的开销。

正如预期的那样，`shared_ptr` 很快就流行起来，并在有些地方被严重滥用。因此，后来我们提供了不引入额外开销的 `unique_ptr`。`unique_ptr` 对它所指的对象拥有独占的所有权，并会在自身被销毁的时候把指向的对象也简单地 `delete` 掉。

```cpp
unique_ptr<Blob> make_Blob(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ... 把很多好东西填到 *p ...
    return p;
}
```

`shared_ptr` 和 `weak_ptr` 是 Peter Dimov 的工作成果 [Dimov et al. 2003]。Howard Hinnant 贡献的 `unique_ptr` 是对 C++98 的 `auto_ptr` 的改进 [Hinnant et al. 2002]。考虑到 `unique_ptr` 是 `auto_ptr` 的即插即用式的替代品，这提供了从标准中（最终）删除有缺陷的功能的难得机会。资源管理指针跟移动语义、完美转发及右值引用的工作密切相关（[§4.2.3](#423-移动语义)）。

资源管理指针被广泛地用于持有对象，以便异常（及类似的情况）不会导致资源泄漏（[§2.2](02%20-%20背景：C++%20的%201979–2006.md#22-第二个十年)）。例如：

```cpp
void old_use(Args a)
{
    auto q = new Blob(a);
    // ...
    if (foo) throw Bad();  // 会泄漏
    if (bar) return;       // 会泄漏
    // ...
    delete q;    // 容易忘
}
```

显式使用 `new` 和 `delete` 的旧方式容易出错，在现代 C++ 中已经不推荐使用（例如，C++ 核心指南（[§10.6](10.md#106-编码指南)））。现在我们可以这样写：

```cpp
void newer_use(Args a)
{
    auto p = unique_ptr<Blob>(new Blob(a));
    // ...
    if (foo) throw Bad();  // 不会泄漏
    if (bar) return;       // 不会泄漏
    // ...
}
```

这种写法更简短、更安全，迅速就流行开去。不过，“智能指针”仍然被过度使用：“它们的确智能，但它们仍然是指针。”除非我们确实需要指针，否则，简单地使用局部变量会更好：

```cpp
void simplest_use(Args a)
{
    Blob b(a);
    // ...
    if (foo) throw Bad(); // 不会泄漏
    if (bar) return;      // 不会泄漏
    // ...
}
```

智能指针用于表示资源所有权的主要用途是面向对象编程，其中指针（或引用）用于访问对象，而对象的确切类型在编译时并不知道。

### 4.2.5 统一初始化

出于历史原因，C++ 有多种初始化的写法，而它们的语义有惊人的不同。

从 C 语言中，C++ 继承了三种初始化形式，并添加了第四种形式：

```cpp
int x;              // 默认初始化（仅适用于静态变量）
int x = 7;          // 值初始化
int a[] = {7,8};    // 聚合初始化
string s;           // 由默认构造函数初始化
vector<int> v(10);  // 由构造函数初始化
```

用于初始化的概念既取决于要初始化的对象的类型，也取决于初始化的上下文。这是一团乱麻，而且人们也认识到这一点。比如，为什么可以用列表初始化内建数组，但却不能初始化 `vector`？

```cpp
int a[] = {7,8};        // 可以
vector<int> v = {7,8};  // 应该可以工作（显然，但是没有）
```

上一个例子令我非常不舒服，因为它违反了 C++ 的根本设计目标，即为内建类型和用户定义的类型提供同等的支持。特别是，因为对数组初始化有比 `vector` 更好的支持，这会鼓励人们使用容易出错的内建数组。

当 C++0x 的工作从 2002 年开始的时候，Daniel Gutson、Francis Glassborow、Alisdair Meredith、Bjarne Stroustrup 和 Gabriel Dos Reis 曾进行了许多讨论和提议，来解决其中一些问题。在 2005 年，Gabriel Dos Reis 和我提出了**统一初始化**的写法，该写法可用于每种类型，并且在程序中的任何地方都具有相同的含义 [Stroustrup and Dos Reis 2005b]。这种写法有望大大简化用户代码并消除许多不易察觉的错误。该表示法是基于使用花括号的列表写法。举例来说：

```cpp
int a = {5};            // 内建类型
int a[] {7,8};          // 数组
vector<int> v = {7,8};  // 具有构造函数的用户定义的类型
```

花括号（`{}`）对于单个值是可选的，并且花括号初始化器列表之前的 `=` 也是可选的。为了统一起见，在许多 C++98 不允许使用花括号或者 `=` 初始化的地方都接受花括号样式的初始化：

```cpp
int f(vector<int>);
int i = f({1,2,3});  // 函数参数

struct X {
    vector<int> v;
    int a[];
    X() : v{1,2}, a{3,4} {}  // 成员初始化器
    X(int);
    // ...
}

vector<int>* p = new vector<int>{1,2,3,4};  // new 表达式
X x {};  // 默认初始化

template<typename T> int foo(T);
int z = foo(X{1});  // 显式构造
```

其中许多的情形，例如为使用 `new` 创建的对象提供初始化器列表，干脆就没法使用以前的方式来完成。

可惜，对于这一理想，我们仅仅达到不完全的近似，我们有的方案只能算大致统一。有些人发现，使用 `{…}` 很别扭，除非 `…` 是同质对象的列表，而其他人则坚持 C 语言中对聚合和非聚合的区分，并且许多人担心没有显式类型标记的列表会导致歧义和错误。例如，以下写法被认为是危险的，不过最终还是被接受了：

```cpp
struct S { string s; int i; };

S foo(S s)
{
    // ...
    return {string{"foo"},13};
}

S x = foo({string{"alpha"},12.3});
```

在一种情况下，对统一写法的追求被一种惯用法击败。考虑：

```cpp
vector<int> v1(10);          // 10 个元素
vector<int> v2 {10};         // 10 个元素还是 1 个值为 10 的元素？
vector<int> v3 {1,2,3,4,5};  // 拥有 5 个元素的 vector
```

使用像 `vector<int> v1(10)` 的指定大小的初始化器的代码有数百万行，而从基本原则上来说，`vector<int> v2 {10}` 确实是模棱两可的。假如是在一门新的语言中，我不会使用普通的整数来表示大小，我会为此指定一种特定的类型（比如 `Size` 或 `Extent`）；举例来说：

```cpp
vector<int> v1 {Extent{10}};  // 10 个元素，默认值为 0
vector<int> v2 {10};          // 1 个元素，值为 10
```

但是，C++ 并不是一门新语言，因此我们决定，在构造函数中进行选择时优先选择初始化器列表解释。这使 `vector<int> v2 {10}` 成为具有一个元素的 `vector`，并且使 `{…}` 初始化器的解释保持一致。但是，当我们想要避免使用初始化器列表构造函数时，这就迫使我们使用 `(…)` 写法。

初始化的问题之一正在于，它无处不在，因此基本上所有程序和语言规则的问题都会在初始化上下文中体现出来。考虑：

```cpp
int x = 7.2;  // 传统的初始化
int y {7.2};  // 花括号初始化
```

从大约 1974 年将浮点数引入 C 语言以来，`x` 的值就是 `7`；也就是说，`7.2` 被隐式截断，从而导致信息丢失。这是错误的来源。花括号初始化不允许窄化转换（此处为截断）。很好，但是升级旧代码变得更加困难：

```cpp
double d = 7.2;
int x = d;   // 可以：截断
int y {d};   // 错误
```

这是一个常见问题的例子。人们想要一条简单的升级路径，但是除非需要做出一些努力和更改，否则一次非常简单的升级的结果是，旧的问题和错误得以保留。改善一门广泛使用的语言比我们一般想像的要难。

经过许多激烈的辩论和许多修改（并非其中每一项我都认为是改进），统一初始化在 2008 年被批准进入 C++0x [Stroustrup 2008b]。

与以往一样，写法是一个有争议的问题，但是最终我们同意有一个标准库类型的 `initializer_list` 用作初始化器列表构造函数的参数类型。举例来说：

```cpp
template<typename T> class vector {
public:
    vector(initializer_list<T>);  // 初始化器列表构造函数
    // ...
};

vector<int> v3 {1,2,3,4,5};  // 具有 5 个元素的 vector
```

令人遗憾的是，统一初始化（`{}`——初始化）的使用并不像我期望的那样广泛。人们似乎更喜欢熟悉的写法和熟悉的缺陷。我似乎陷入了 N+1 问题：你有 N 个不兼容和不完整的解决方案，因此添加了一个新的更好的解决方案。不幸的是，原始的 N 个解决方案并没有消失，所以你现在有了 N+1 个解决方案。公平地说，有一些细微的问题超出了本文的范围，这些问题只是在 C++14、C++17 和 C++20 中被逐步补救。我的印象是，泛型编程和对更简洁的表示法的推进正在慢慢增加统一初始化的吸引力。所有标准库容器（如 `vector`）都有初始化器列表构造函数。

### 4.2.6 `nullptr`

在 C 和 C++ 中，如果将字面量 `0` 赋值给指针或与指针比较时它表示空指针。更令人困惑的是，如果将任何求值为零的整数常量表达式赋值给指针或与指针比较时它也表示空指针。例如：

```cpp
int* p = 99-55-44; // 空指针
int* q = 2;        // 错误：2 是一个 int，而不是一个指针
```

这使很多人感到烦恼和困惑，因此有一个标准库宏 `NULL`（从 C 中采用），它在标准 C++ 中定义为 `0`。某些编译器会对 `int* p = 0` 提出警告；但是我们仍然没法为函数针对指针和整数重载而避免 `0` 的歧义。

这很容易通过给空指针命名来解决，但是不知何故没有人能提出一份人们能达成一致的提议。在 2003 年的某个时候，我正通过电话参加一个会议，讨论如何给空指针命名。如 `NULL`、`null`、`nil`、`nullptr` 和 `0p` 等建议名都是备选方案。照旧，那些简短而“漂亮”的名字已经被使用了成千上万次，因此不能在不破坏数百万行代码的情况下使用。我听了数十次这样的讨论，有点厌烦了，只是在似听非听。人们说到 null pointer, null ptr, nullputter 的变体。我醒过来说：“你们都在说 `nullptr`。我想我没有在代码中看到过它”。

Herb Sutter 和我写下了该提案 [Sutter and Stroustrup 2003]，该提案在 2007 年相对容易地通过了（仅仅进行了四次小修订后），所以现在我们可以说：

```cpp
int p0 = nullptr;
int* p1 = 99-55-44;  // 可以，为了兼容性
int* p2 = NULL;      // 可以，为了兼容性

int f(char*);
int f(int);

int x1 = f(nullptr); // f(char*)
int x2 = f(0);       // f(int)
```

我对 `nullptr` 的发音是“null pointer”。

我仍然认为如能将宏 `NULL` 定义为 `nullptr` 可以消除一类重要的问题，但委员会认为这一改变过于激进。

### 4.2.7 `constexpr` 函数

在 2003 年，Gabriel Dos Reis 和我提出了用于在 C++ 中进行常量表达式求值的一种根本不同且明显更好的机制 [Dos Reis 2003]。人们当时使用（无类型的）宏和贫乏的 C 语言定义的常量表达式。另一些人则开始使用模板元编程来计算值（[§10.5.2](10.md#1052-元编程)）。“这既乏味又容易出错” [Dos Reis and Stroustrup 2010]。我们的目标是

- 让编译期计算达到类型安全
- 一般来说，通过将计算移至编译期来提高效率
- 支持嵌入式系统编程（尤其是 ROM）
- 直接支持元编程（而非**模板**元编程（[§10.5.2](10.md#1052-元编程)））
- 让编译期编程与“普通编程”非常相似

这个想法是简单的：允许在常量表达式中使用以 `constexpr` 为前缀的函数，还允许在常量表达式中使用简单用户定义类型，叫字面量类型。字面量类型基本上是一种所有运算都是 `constexpr` 的类型。

考虑这样一个应用，为了提高效率、支持 ROM 或可靠性，我们想使用一套单位制 [Dos Reis and Stroustrup 2010]：

```cpp
struct LengthInKM {
    constexpr explicit LengthInKM(double d) : val(d) { }
    constexpr double getValue() { return val; }
private:
    double val;
};

struct LengthInMile {
    constexpr explicit LengthInMile(double d) : val(d) { }
    constexpr double getValue() { return val; }
    constexpr operator LengthInKM() { return LengthInKM(1.609344 * val); }
private:
    double val;
};
```

有了这些，我们可以制作一个常量表，而不必担心单位错误或转换错误：

```cpp
LengthInKM marks[] = { LengthInMile(2.3), LengthInMile(0.76) };
```

传统的解决方案要么需要更多的运行时间，要么需要程序员在草稿纸上算好值。我对单位制的兴趣是由 1999 年的火星气候探测者号的失事激发的，事故原因是单位不匹配没有被发现 [Stephenson et al. 1999]。

`constexpr` 函数可以在编译期进行求值，因此它无法访问非本地对象（它们在编译时还不存在），因此 C++ 获得了一种纯函数。

为什么我们要求程序员应该使用 `constexpr` 来标记可以在编译期执行的函数？原则上，编译器可以弄清楚在编译期可以计算出什么，但是如果没有标注，用户将受制于各种编译器的聪明程度，并且编译器需要将所有函数体“永远”保留下来，以备常量表达式在求值时要用到它们。我们选择 `constexpr` 一词是因为它足够好记，但又“足够奇怪”而不会破坏现有代码。

在某些地方，C++ 需要常量表达式（例如，数组边界和 case 标签）。另外，我们可以通过将变量声明为 `constexpr` 来要求它在编译期被初始化：

```cpp
constexpr LengthInKM marks[] = { LengthInMile(2.3), LengthInMile(0.76) };

void f(int x)
{
    int y1 = x;
    constexpr int y2 = x;   // 错误：x 不是一个常量
    constexpr int y3 = 77;  // 正确
}
```

早期的讨论集中在性能和嵌入式系统的简单示例上。直到后来（大约从 2015 年开始），`constexpr` 函数才成为元编程的主要支柱（[§10.5.2](10.md#1052-元编程)）。C++14 允许在 `constexpr` 函数中使用局部变量，从而支持了循环；在此之前，它们必须是纯函数式的。C++20（最终，在首次提出后约 10 年）允许将字面类型用作值模板参数类型 [Maurer 2012]。因此，C++20 将非常接近最初的目标（1979 年），即在可以使用内建类型的地方也都可以使用用户定义的类型（[§2.1](02%20-%20背景：C++%20的%201979–2006.md#21-第一个十年)）。

`constexpr` 函数很快变得非常流行。它们遍布于 C++14、C++17 和 C++20 标准库，并且不断有相关建议，以求在 `constexpr` 函数中允许更多的语言构造、将 `constexpr` 应用于标准库中的更多函数，以及为编译期求值提供更多支持（[§9.3.3](09.md#933-编译期计算支持)）。

但是，`constexpr` 函数进入标准并不容易。它们一再被认为是无用和无法实现的。实现 `constexpr` 函数显然需要改进较老的编译器，但是很快，所有主要编译器的作者都证明了“无法实现”的说法是错误的。关于 `constexpr` 的讨论是有史以来最激烈、最不愉快的。让初始版本通过标准化流程 [Dos Reis and Stroustrup 2007] 花费了四年的时间，而完整地完成又花了十二年的时间。

### 4.2.8 用户定义字面量

“用户定义字面量”是一个非常小的功能。但是，它合乎我们的总体目标，即让用户定义类型得到和内建类型同等的支持。内建类型有字面量，例如，`10` 是整数，`10.9` 是浮点数。我试图说服人们，对于用户定义类型，显式地使用构造函数是等价的方式；举例来说，`complex<double>(1.2,3.4)` 就是 `complex` 的字面量等价形式。然而，许多人认为这还不够好：写法并不传统，而且不能保证构造函数在编译期被求值（尽管这还是早年间的事）。对于 `complex`，人们想要 `1.2+3.4i`。

与其他问题相比，这似乎并不重要，所以几十年来什么都没有发生。2006 年的一天，David Vandevoorde（EDG）、Mike Wong（IBM）和我在柏林的一家中餐馆吃了一顿丰盛的晚餐。我们在餐桌边聊起了天，于是一个设计浮现在一张餐巾纸上。这个讨论的起因是 IBM 的一项十进制浮点提案中对后缀的需求，该提案最终成了一个独立的国际标准 [Klarer 2007]。在大改后，该设计在 2008 年成为**用户定义字面量**（通常称为 UDL）[McIntosh et al. 2008]。当时让 UDL 变得有趣的重要发展是 `constexpr` 提案的进展（[§4.2.7](#427-constexpr-函数)）。有了它，我们可以保证编译期求值。

照例，找到一种可接受的写法是一个问题。我们决定使用晦涩的 `operator""` 作为字面量运算符（literal operator）的写法是可以接受的，毕竟 `""` 是一个字面量。然后，`""x` 是后面跟着后缀 `x` 的字面量。这样一来，要定义一个用于 `complex` 数的 `Imaginary` 类型，我们可以定义：

```cpp
constexpr Imaginary operator""i(long double x) { return Imaginary(x); }
```

现在，`3.4i` 是一个 `Imaginary`，而 `1.2+3.4i` 是 `complex<double>(1.2,3.4)`。任务完成！

这一功能的语言技术细节相当古怪，但我认为对于一个相对很少使用的特性来说，这是合理的。即使在大量使用 UDL 时，字面量运算符的定义也很少。最重要的是后缀的优雅和易用性。对于许多类型，重要的是可以在编译时完成从内建类型到用户定义类型的转换。

很自然，人们使用 UDL 来定义许多有用的类型的字面量，有些来自标准库（例如，`s` 代表 秒，`s` 代表 `std::string`）。关于支持二进制字面量的讨论，Peter Sommerlad（HSR）提出了我认为的“最佳滥用规则”奖的候选方案：适当地定义 `operator""_01(long int)`，于是 `101010_01` 就成了个二进制字面量！当惊讶和笑声平息下来后，委员会决定在语言本身里定义二进制字面量并使用 `0b` 作为前缀，表示“binary”（例如 `0b101010`），类似于使用 `0x` 表示“hexadecimal”（例如 `0xDEADBEEF`）。

### 4.2.9 原始字符串字面量

这是一个罕见的简单特性，它的唯一目的是为容易出错的写法提供一种替代方法。和 C 一样，C++ 使用反斜杠作为转义字符。这意味着要在字符串字面量中表示反斜杠，你需要使用双反斜杠（`\\`），当你想在字符串中使用双引号时，你需要使用 `\"`。然而，通常的正则表达式模式广泛使用反斜杠和双引号，所以模式很快变得混乱和容易出错。考虑一个简单的例子（美国邮政编码）：

```cpp
regex pattern1 {"\\w{2}\\s*\\d{5}(-\\d{4})?"}; // 普通字符串字面量

regex pattern2 {R"(\w{2}\s*\d{5}(-\d{4})?)"};  // 原始字符串字面量
```

这两种模式是相同的。**原始字符串字面量** `R"(…)"` 的括号可以精调以容纳更复杂的模式，但是当你使用正则表达式（[§4.6](#46-c11标准库组件)）时，最简单的版本就足够了，而且非常方便。当然，提供原始字符串字面量是一个小细节，但是（类似于数字分隔符（[§5.1](05.md#51-数字分隔符)）），深受需要大量使用字面量的人们的喜爱。

原始字符串字面量是 Beman Dawes 在 2006 年 [Dawes 2006] 基于使用 Boost.Regex [Maddock 2002] 的经验而提出来的。

### 4.2.10 属性

在程序中，属性提供了一种将本质上任意的信息与程序中的实体相关联的方法。例如：

```cpp
[[noreturn]] void forever()
{
    for (;;) {
        do_work();
        wait(10s);
    }
}
```

属性 `[[noreturn]]` 通知编译器或其他工具 `forever()` 永远不会返回，这样它就可以抑制关于缺少返回的警告。属性用 `[[…]]` 括起来。

属性最早是在 2007 年由库工作组的负责人 Alisdair Meredith [Meredith 2007] 提出来的，目的是消除专有属性写法（例如 `__declspec` 和 `__attribute__`）之间的不兼容性，这种不兼容性会使库实现更加复杂。对此，Jens Maurer 和 Michael Wong 对问题进行了分析，并提出了 `[[…]]` 语法，方案是基于 Michael 为 IBM 的 XL 编译器所做的实现 [Maurer and Wong 2007]。除了对大量不可移植的实践进行标准化之外，这还将允许用更少的关键字来完成语言扩展，而新的关键字总是有争议的。

该提案提到了可能的使用：覆盖虚函数的明确语法，动态库，用户控制的垃圾收集，线程本地存储，控制对齐，标识“简旧数据”（POD）类，default 和 delete 的函数，强类型枚举，强类型 typedef，无副作用的纯函数，final 覆盖，密封类，对并发性的细粒度控制，运行期反射支持，及轻量级契约编程主持。在早期的讨论中还提到了更多。

“属性”当然是一个使某些事情变得更简单的特性，但我不确定它是否鼓励了良好的设计，或者它简化的“事情”总是能产生最大的好处。我可以想象属性打开了闸门，放进来一大堆不相关的、不太为人们了解的、次要的特性。任何人都可以为编译器添加一个属性，并游说各处采用它，而不是向 WG21 提出一个特性。许多程序员就是喜欢这些小特性。不需要引入关键字和修改语法能降低门槛。但同样能造成不可避免的对特性交互关注度不够，造成重叠而不兼容的类似特性出现在不同的编译器中。这种情况在私有扩展中已经发生过了，但我认为它们是不可避免的、局部的，而且往往是暂时的。

为了限制潜在的损害，我们决定属性应该意味着不改变程序的语义。也就是说，忽略属性，编译器不会有任何危害。多年来，这条“规则”几乎奏效。大多数标准属性——尽管不是全部——没有语义效果，即使它们有助于优化和错误检测。

最后，大多数最初那些建议的对属性的使用都通过普通的语法和语言规则来解决。

C++11 增加了标准属性 `[[noreturn]]` 和 `[[carries_dependency]]`。

C++17 增加了 `[[fallthrough]]`、`[[nodiscard]]` 和 `[[maybe_unused]]`。

C++20 增加了 `[[likely]]`、`[[unlikely]]`、`[[deprecated(message)]]`、`[[no_unique_address]]` 和 `[[using: …]]`。

我仍然看到属性扩散是一个潜在的风险，但到目前为止，水闸还没有打开。C++ 标准库大量使用了属性；`[[nodiscard]]` 属性尤其受欢迎，特别用来防止由于没有使用本身是资源句柄的返回值而造成的潜在资源泄漏。

属性语法被用于（失败的）C++20 契约设计（[§9.6.1](09.md#961-契约)）。

### 4.2.11 垃圾收集

从 C++ 的早期开始，人们就考虑**可选**的垃圾收集（对于“可选”有各种定义）[Stroustrup 1993, 2007]。经过一番争论，C++11 为 Mike Spertus 和 Hans-J. Boehm 设计的保守垃圾收集器提供了一个接口 [Boehm and Spertus 2005; Boehm et al. 2008]。然而，很少有人留意到这一点，更少有人使用了垃圾收集（尽管有好的收集器可用）。设计的方法是 [Boehm et al. 2008]：

> 同时支持垃圾收集实现和基于可达性的泄漏检测器。这是通过把“隐藏指针”的程序定为未定义行为来实现的；举例来说，将指针与另一个值进行异或运算，然后将它转换回普通指针并对其进行解引用就是一种隐藏行为。

这项工作造福了 C++ 语义的精确规范，并且 C++ 中也存在一些对垃圾收集的使用（例如，在 Macaulay2 中 [Eisenbud et al. 2001; Macaulay2 2005–2020]）。然而，垃圾收集器不处理非内存资源，而 C++ 社区通常选择使用资源管理指针（[§4.2.4](#424-资源管理指针)）和 RAII（[§2.2.1](02%20-%20背景：C++%20的%201979–2006.md#221-语言特性)）二者的组合。

## 4.3 C++11：改进对泛型编程的支持

泛型编程（及其产物模板元编程（[§10.5.2](10.md#1052-元编程)））在 C++ 98 中迅速轻松地获得了成功。它的使用对语言造成了严重的压力，而不充分的语言支持导致了巴洛克式矫揉造作的编程技巧和可怕的错误消息。这证明了泛型编程和元编程的实用性，许多明智的程序员为了获得其好处而甘愿承受其痛苦。这些好处是

- 超越以 C 风格或面向对象风格所可能获得的灵活性
- 更清晰的代码
- 更细的静态类型检查粒度
- 效率（主要来自内联、让编译器同时查看多处的源代码，以及更好的类型检查）

C++11 中支持泛型编程的主要新特性有：

- [§4.3.1](#431-lambda-表达式)：lambda 表达式
- [§4.3.2](#432-变参模板)：变参模板
- [§4.3.3](#433-别名)：`template` 别名
- [§4.3.4](#434-tuple)：`tuple`
- [§4.2.5](#425-统一初始化)：统一初始化

在 C++11 中，概念本应是改进支持泛型编程的核心，但这并没有发生（[§6.2.6](06.md#626-哪里出错了)）。我们不得不等到 C++20（[§6.4](06.md#64-c20-概念)）。

### 4.3.1 lambda 表达式

BCPL 允许将代码块作为表达式，但是为了节省编译器中的空间，Dennis Ritchie 没有在 C 中采用这个特性。我在这点上遵循了 C 的做法，但是添加了 `inline` 函数，从而（重新）得到在没有函数调用的开销下执行代码的能力。不过，这仍然不能提供以下能力

- 把代码写在需要它的那个准确位置上（通常作为函数参数）。
- 从代码内部访问代码的上下文。

在 C++98 的开发过程中，曾有人提议使用局部函数来解决第二点，但被投票否决了，因为这可能成为缺陷的来源。

C++ 不允许在函数内部定义函数，而是依赖于在类内部定义的函数。这使得函数的上下文可以表示为类成员，因而函数对象变得非常流行。**函数对象**只是一个带有调用运算符（`operator()()`）的类。这曾是一种非常高效和有效的技术，我（和其他人）认为有名字的对象比未命名的操作更清晰。然而，只有当我们可以在某样东西使用的上下文之外给它一个合理的名称，特别是如果它会被使用多次时，这种清晰度上的优势才会表现出来。

2002 年，Jaakko Järvi 和 Gary Powell 编写了 Boost.Lambda 库 [Järvi and Powell 2002] 这让我们可以写出这样的东西

```cpp
find_if(v.begin(), v.end(), _1<i);  // 查找值小于 i 的元素
```

这里，`_1` 是代码片段 `_1<i` 的某个第一个实参的名称，而 `i` 是表达式所在作用域（enclosing scope）中的一个变量。`_1<i` 展开为一个函数对象，其中 `i` 被绑定到一个引用，`_1` 成为 `operator()()` 的实参：

```cpp
struct Less_than {
    int& i;
    Less_than(int& ii) :i(ii) {}  // 绑定到 i
    bool operator()(int x) { return x<i; }  // 跟参数比较
}
```

lambda 表达式库是早期模板元编程的典范（[§10.5.2](10.md#1052-元编程)），非常方便和流行。不幸的是，它的效率并不特别高。多年来，我追踪了它相对于手工编码的同等实现的性能，发现它的开销是后者的 2.5 倍且这种差距相当一致。我不能推荐一种方便但却很慢的东西。这样做会损害 C++ 作为产生高效代码的语言的声誉。显然，这种慢在一定程度上是由于优化不当造成的，但出于这个和其他原因，我们有一群人在 Jaakko Järvi 领导下决定将 lambda 表达式作为一种语言特性 [Willcock et al. 2006] 来提出。举例来说：

```cpp
template<typename Oper>
void g(Oper op)
{
    int xx = op(7);
    // ...
}

void f()
{
    int y = 3;
    g(<>(int x) -> int {return x + y;});  // 以 lambda 表达式作为参数调用 g()
}
```

这里，`xx` 会变成 `3+7`。

`<>` 是 lambda 表达式引导器。我们不敢提出一个新的关键词。

这一提议引起了相当多的兴奋和许多热烈的讨论：

- 语法应该是富有表现力的还是简洁的？
- lambda 表达式可以从哪个作用域引用什么名字？[Crowl 2009]。
- 从 lambda 表达式生成的函数对象应该是可变的吗？默认情况下不是。
- lambda 表达式能是多态的吗？到 C++14 才可以（[§5.4](05.md#54-泛型-lambda-表达式)）。
- lambda 表达式的类型是什么？独有的类型，除非它基本上是一个局部函数。
- lambda 表达式可以有名字吗？不。如果你需要一个名字，就把它赋给一个变量。
- 名称是由值绑定还是由引用绑定？你来选择。
- 变量可以移动到 lambda 表达式中（相对于复制）吗？到 C++14 才可以（[§5](05.md#5-c14完成-c11)）。
- 语法是否会与各种非标准扩展发生冲突？（不严重）。

到 2009 年 lambda 表达式被批准时，语法已经发生了变化，变得更加合乎惯例 [Vandevoorde 2009]：

```cpp
void abssort(float* x, unsigned N)
{
    std::sort(x, x+N,
        [](float a, float b) { return std::abs(a) < std::abs(b); }
             );
}
```

从 `<>` 切换到 `[]` 是由 Herb Sutter 建议并由 Jonathan Caves 实现的。这种变化在一定程度上是由于需要一种简单的方法来指定 lambda 表达式可以使用周围作用域中的哪些名称。Herb Sutter 回忆道：

> 我的并行算法项目需要 lambda 表达式，这是我的动机……看到 EWG 所采用的 lambda 表达式那实在丑到爆的用法，以及从语法一致性/干净性的角度来看极为糟糕的设计（例如，捕获出现在两个分开的位置，语法元素使用不一致，顺序错误——因为“构造函数”元素应该先出现然后才是调用“运算符”元素，以及其他一些小问题）。

默认情况下，lambda 表达式不能引用在本地环境的名字，所以它们只是普通的函数。然而，我们可以指定 lambda 表达式应该从它的环境中“捕获”一些或所有的变量。回调是 lambda 表达式的一个常见用例，因为操作通常只需要写一次，并且操作会需要安装该回调的代码上下文中的一些信息。考虑：

```cpp
void test()
{
    string s;
    // ... 为 s 计算一个合适的值 ...
    w.foo_callback([&s](int i){ do_foo(i,s); });
    w.bar_callback([=s](double d){ return do_bar(d,s); });
}
```

`[&s]` 表示 `do_foo(i,s)` 可以使用 `s`，`s` 通过引用来传递（“捕获”）。`[=s]` 表示 `do_bar(d,s)` 可以使用 `s`，`s` 是通过值传递的。如果回调函数在与 `test` 相同的线程上被调用，`[&s]` 捕获可能效率更高，因为 `s` 没有被复制。如果回调函数在不同的线程上被调用，`[&s]` 捕获可能是一个灾难，因为 `s` 在被使用之前可能会超出作用域；这种情况下，我们想要一份副本。一个 `[=]` 捕获列表意味着“将所有局部变量复制到 lambda 表达式中”。而一个 `[&]` 捕获列表意味着“lambda 表达式可以通过引用指代所有局部变量”，并意味着 lambda 表达式可以简单地实现为一个局部函数。事实证明，捕获机制的灵活性非常有价值。捕获机制允许控制可以从 lambda 表达式引用哪些名称，以及如何引用。这是对 1990 年代人们担心局部函数容易出错的一种回答。

lambda 表达式的实现基本上是编译器构建一个合适的函数对象并传递它。捕获的局部变量成为由构造函数初始化的成员，lambda 表达式的代码成为函数对象的调用运算符。例如，`bar_callback` 变成：

```cpp
struct __XYZ {
    string s;
    __XYZ(const string& ss) : s{ss} {}
    int operator()(double d) { return do_bar(d,s); }
};
```

lambda 表达式的返回类型可以从它的返回语句推导出来。如果没有 return 语句，lambda 表达式就不会返回任何东西。

我把 lambda 表达式归类为对泛型编程的支持，因为最常见的用途之一——也是主要的动机——是用作 STL 算法的参数：

```cpp
// 按降序排序：
sort(v.begin(),v.end(),[](int x, int y) { return x>y; });
```

因此，lambda 表达式显著地增加了泛型编程的吸引力。

在 C++11 之后，C++14 添加了泛型 lambda 表达式（[§5.4](05.md#54-泛型-lambda-表达式)）和移动捕获（[§5](05.md#5-c14完成-c11)）。

### 4.3.2 变参模板

2004 年，Douglas Gregor、Jaakko Järvi 和 Gary Powell（当时都在印第安纳大学）提出了**变参模板** [Gregor et al. 2004] 的特性，用来：

> 直接解决两个问题：
> - 不能实例化包含任意长度参数列表的类模板和函数模板。
> - 不能以类型安全的方式传递任意个参数给某个函数

这些都是重要目标，但我起初发现其解决方案过于复杂，记法太过晦涩，按我的品味其编程风格又太递归。不过在 Douglas Gregor 于 2004 年做的精彩演示之后，我改变了主意并全力支持这项提案，帮助它在委员会顺利通过。我被说服的部分原因是变参模板和当时的变通方案在编译时间上的对比测量。编译时间过长的问题随模板元编程的大量使用（[§10.5.2](10.md#1052-元编程)）变得越来越严重，对此变参模板是一项重大（有时是 20 倍）改进。可惜，变参模板越变越流行，也成了 C++ 标准库中必需的部分，以至编译时间的问题又出现了。不过，成功的惩罚（在当时）还是在遥远的将来。

变参模板的基本思路是，递归构造一个**参数包**，然后在另一个递归过程来使用它。递归技巧是必须的，因为参数包中的每个元素都有它自己的类型（和大小）。

考虑 `printf` 的一种实现，能够处理可由标准库 iostream 的输出运算符 `<<` 输出的每种类型 [Gregor 2006]：

> 为了创建类型安全的 `printf()`，我们采用以下策略：写出字符串直至碰到第一个格式说明符，按格式打印相应的值，然后递归调用 `printf()` 来打印字符串剩下部分和其余各值。

```cpp
template<typename T, typename... Args>
void printf(const char* s, const T& value, const Args&... args)
{
    while (*s) {
        if (*s == '%' && *++s != '%') { // 忽略 % 后的字符：
                                        // 我们已经知道要打印的类型了！
            std::cout << value;
            return printf(++s, args...);
        }
        std::cout << *s++;
    }
    throw std::runtime error("extra arguments provided to printf");
}
```

这里 `<typename T, typename... Args>` 指定了一个传统的列表，有头（`T`）和尾（`Args`）。每次调用会处理头，然后以尾为参数来调用自身。普通字符会被简单打印，而格式符 `%` 则表示某个参数要被打印了。Doug（当时他住在印第安纳州）提供了一个测试例子：

```cpp
const char* msg = "The value of %s is about %g (unless you live in %s).\n";
printf(msg, std::string("pi"), 3.14159, "Indiana");
```

结果会打印

```
The value of pi is about 3.14159 (unless you live in Indiana).
```

这个实现的好处之一是，和标准的 `printf` 不同，用户定义的类型也和内建类型一样会得到正确处理。通过使用 `<<` 也避免了类型指示符和参数类型之间的不匹配，比如 `printf("%g %c","Hello",7.2)`。

这个 `printf` 所展示的技巧是 C++20 `format`（[§9.3.7](09.md#937-格式化)）的基础之一。

变参模板的缺点是容易导致代码膨胀，因为 N 个参数意味着模板的 N 次实例化。

### 4.3.3 别名

C 定义类型别名的机制是靠 `typedef`。例如：

```cpp
typedef double (*pf)(int);   // pf 是一个函数指针，该函数接受一个 int
                             // 返回一个 double
```

这是有点诘屈聱牙，但是类型别名在 C 和 C++ 代码中非常有用，使用非常普遍。从最初有 C++ 模板的时候，人们就一直考虑是否可以有 **typedef 模板**；如果可以，它们应该是什么样子。2002 年时，Herb Sutter 提出一个方案 [Sutter 2002]：

```cpp
template<typename A, typename B> class X { /* ... */ };
template<typename T> typedef X<T,int> Xi;  // 定义别名
Xi<double> Ddi;                            // 相当于 X<double, int>
```

在此基础之上，又经历了冗长的邮件列表讨论，Gabriel Dos Reis（当时在法国国立计算机及自动化研究院）和 Matt Marcus（Adobe）解决了特化相关的若干棘手问题，并引入 David Vandevoorde 称之为**别名模板**的简化语法 [Dos Reis and Marcus 2003]。例如：

```cpp
template<typename T, typename A> class MyVector { /* ... */};
template<typename T> using Vec = MyVector<T, MyAlloc<T> >;
```

其中的 `using` 语法，即要引入的名字总是出现在前面，则是我的建议。

我和 Gabriel Dos Reis 一道把这个特性推广成一个（几乎）完整的别名机制，并最终得到接受 [Stroustrup and Dos Reis 2003c]。即便不涉及模板，它也给了人们一种记法上的选择：

```cpp
typedef double (*analysis_fp)(const vector<Student_info>&)；

using analysis_fb = double (*)(const vector<Student_info>&);
```

类型和模板别名是某些最有效的零开销抽象及模块化技巧的关键。别名让用户能够使用一套标准的名字而同时让各种实现使用各自（不同）的实现技巧和名字。这样就可以在拥有零开销抽象的同时保持方便的用户接口。考虑某通讯库（使用了 Concepts TS [Sutton 2017] 和 C++20 的简化记法）中的一个实例：

```cpp
template<InputTransport Transport, MessageDecoder MessageAdapter>
class InputChannel {
public:
    using InputMessage = MessageAdapter::InputMessage<Transport::InputBuffer>;
    using MessageCallback = function<void(InputMessage&&)>;
    using ErrorCallback = function<void(const error_code&)>;
    // ...
};
```

概念和别名对于规模化地管理这样的组合极有价值。

`InputChannel` 的用户接口主要由三个别名组成，`InputMessage`、`MessageCallback` 和 `ErrorCallback`，它们由模板的参数初始化而来。

`InputChannel` 需要初始化它的传输层，该传输层由一个 `Transport` 对象表示。然而，`InputChannel` 不应该知道传输层的实现细节，所以它不应直接初始化它的 `Transport` 成员。变参模板（[§4.3.2](#432-变参模板)）就派上了用场：

```cpp
template<InputTransport Transport, MesssageDecoder MessageAdapter>
class InputChannel {
public:
    template<typename... TransportArgs>
        InputChannel(TransportArgs&&... transportArgs)
            : _transport {forward<TransportArgs>(transportArgs)... }
        {}
    // ...
    Transport _transport;
}
```

如果没有变参模板，就得定义出一个通用接口来初始化传输层，或者得把传输层暴露给用户。

这个漂亮的例子展示了如何把 C++11 的特性（加上概念）组合起来以优雅的零开销方案解决一个困难问题。

### 4.3.4 `tuple`

C++98 有个 `pair<T,U>` 模板；它主要用来返回成对的值，比如两个迭代器或者一个指针加上一个成功标志。2002 年时，Jaakko Järvi 在参考 Haskell、ML、Python 和 Eiffel 后，提议把这个思路进一步推广，变成 `tuple`（元组）[Järvi 2002]：

> 元组是大小固定而成员类型可以不同的容器。作为一种通用的辅助工具，它们增加了语言的表现力。举几个元组类型一般用法的例子：
> - 作为返回类型，用于需要超过一个返回类型的函数
> - 编组相关的类型或对象（如参数列表中的各条目）成为单个条目
> - 同时赋多个值

对于特定的设计意图，定义一个类，并在里面对成员进行合理命名、清晰表述成员间的语义关系，通常会是最好的做法。Alisdair Meredith 在委员会内力陈以上观点，劝阻在接口中过度使用未命名的类型。然而，当撰写泛型代码时，把多个值打包到一个元组中作为一个实体进行处理往往能简化实现。元组对于不值得命名、不值得设计类的一些中间情况特别有用。

比如，考虑一个只需返回三个值的矩阵分解：

```cpp
auto SVD(const Matrix& A) -> tuple<Matrix, Vector, Matrix>
{
    Matrix U, V;
    Vector S;
    // ...
    return make_tuple(U,S,V);
};

void use()
{
    Matrix A, U, V;
    Vector S;
    // ...
    tie(U,S,V) = SVD(A); // 使用元组形式
}
```

在这里，`make_tuple()` 是标准库函数，可以从参数中推导元素类型来构造 `tuple`，`tie()` 是标准库函数，可以把 `tuple` 的成员赋给有名字的变量。

使用 C++17 的结构化绑定（[§8.2](08.md#82-结构化绑定)），上面例子可简化为：

```cpp
auto SVD(const Matrix& A) -> tuple<Matrix, Vector, Matrix>
{
    Matrix U, V;
    Vector S;
    // ...
    return {U,S,V};
};

void use()
{
    Matrix A;
    // ...
    auto [U,S,V] = SVD(A); // 使用元组形式和结构化绑定
}
```

进一步的记法简化被提议加入 C++20 [Spertus 2018]，但没来得及成功通过：

```cpp
tuple SVD(const Matrix& A) // 从返回语句中推导出元组模板参数
{
    Matrix U, V;
    Vector S;
    // ...
    return {U,S,V};
};
```

为什么 `tuple` 不是语言特性？我不记得当时有人这么问过，尽管一定有人想到过这一点。长期以来（自 1979 年），我们的策略就是，如果能合理地将新特性以库的形式加入 C++，就不要以语言特性加入；如果不能，就要改进抽象机制使其成为可能。这一策略有显而易见的优势：

- 通常对一个库做试验比对一个语言特性做试验更容易，这样我们就更快地得到更好的反馈。
- 库可以早在所有编译器升级到支持新特性之前就得到严肃使用。
- 抽象机制（类，模板等）上的改进，能在眼前问题之外提供帮助。

`tuple` 以 Boost.Tuple 为基础构建，其实现之巧妙也足以让众人引以为傲。在这一特性上，并没有出现运行期效率方面的理由，使我们去偏向一个语言实现而不是库实现。这让人颇为敬佩。

参数包就是一个拥有编译器支持接口的元组的例子（[§4.3.2](#432-变参模板)）。

元组大量用于 C++ 和其他语言（例如 Python）交互的程序库里。

## 4.4 C++11：提高静态类型安全

依赖静态类型安全有两大好处：

- 明确意图
  - 帮助程序员直接表达想法
  - 帮助编译器捕获更多错误
- 帮助编译器生成更好的代码。

第二点是第一点的结果。受 Simula 的启发，我对 C++ 的目标是要提供一个灵活可扩展的静态类型系统。目的不仅是类型安全，还要能够直接表达细粒度的区别，例如物理单位检查（[§4.2.7](#427-constexpr-函数)）。一段只用了内建类型如整型和浮点型写成的程序，也算是类型安全但却没有由此带来特别的安全优势。那样的代码没有直接表达应用中的概念。特别需要指出，`int` 或者 `string` 几乎可以表达任何东西，所以传递这样的值就完全没有给出被传递值的任何语义信息。

C++11 中与类型安全直接相关的改进有：

- 对于线程和锁的类型安全接口——避免 POSIX 和 Windows 在并发代码中对 `void**` 及宏的依赖（[§4.1.2](#412-线程和锁))
- 范围 `for`——避免错误地指定范围（[§4.2.2](#422-范围-for)）
- 移动语义——解决指针的过度使用问题（[§4.2.3](#423-移动语义)）
- 资源管理指针（`unique_ptr` 和 `shared_ptr`（[§4.2.4](#424-资源管理指针)））
- 统一初始化——让初始化更通用，更一致，更安全（[§4.2.5](#425-统一初始化)）
- `constexpr`——消除多处（无类型和无作用域的）宏的使用（[§4.2.7](#427-constexpr-函数)）
- 用户定义的字面量——让用户定义类型更像内建类型（[§4.2.8](#428-用户定义字面量)）
- `enum class`——消除一些涉及整型常量的弱类型做法
- `std::array`——避免内建数组不安全地“退化”成指针

委员会一直收到建议，应当通过禁止不安全特性（例如，废弃像内建数组和类型转换这样的 C 风格特性）来改善类型安全。然而，移除特性（“取缔”它们）的尝试一再失败，因为用户无视移除的警告并坚持要求实现的提供者继续支持这些特性。一个更可行的方式似乎是给用户提供使用指南和实施指南的手段，同时保持标准本身继续和先前的版本兼容（[§10.6](10.md#106-编码指南)）。

## 4.5 C++11：支持对库的开发

设计 C++ 基础库，往往要在性能和易用性方面同 C++ 及其他语言的内置功能。这时，查找规则、重载决策、访问控制、模板实例化规则等特性之中的微妙之处会组合起来，产生强大的表达能力，但同时也暴露出可怕的复杂性。

### 4.5.1 实现技巧

有些实现技巧实属“黑魔法”，不应当暴露给非专家。大部分程序员可以愉快地编写多年好的 C++ 代码，而不用了解这些复杂手段和神秘技巧。遗憾的是，初学者们一拥而上去研究这些最可怕的特殊代码，并从给别人（经常是错误地）解释它们的过程中得到巨大的自豪感。博主和演讲者们通过显摆令人提心吊胆的例子抬高他们的名望。这是 C++ 语言复杂性名声的一个主要来源。在其他语言中，要么不提供这样的优化机会，要么手段被藏在了优化器内部。

我不能在此深入细节，就只提一个技巧，它在 C++11 的发展中作为关键技巧出现，并在基于模板的库（包括 C++ 标准库）中广为使用。它以奇怪的缩写为人所知：**SFINAE**（Substitution Failure Is Not An Error，替换失败不是错误）。

你如何表达一个当且仅当某个谓词为真时才有的操作？概念为 C++20 提供了这样的支持（GCC 自 2015 年开始支持），但在 21 世纪早期，人们不得不依赖于晦涩的语言规则。例如：

```cpp
template<typename T, typename U>
struct pair {
    T first;
    U second;
    // ...
    enable_if<is_copy_assignable<T>::value
              && is_copy_assignable<U>::value,pair&>::type
        operator=(const pair&);
    //...
};
```

这样，当且仅当 `pair` 的两个成员都有拷贝赋值操作时 `pair` 才有拷贝赋值操作。这超乎寻常的丑陋，但它对于定义和实现基础库也超乎寻常的有用——在概念还没有出现时。

要点在于，如果成员都有拷贝赋值，`enable_if<…,pair&>::type` 会成为一个普通的 `pair&`，否则它的实例化就会失败（因为 `enable_if` 没有为赋值提供一个返回类型）。这里 SFINAE 就起作用了：替换失败不是错误；失败的结果就如同整条声明不曾出现一样。

这里的 `is_copy_assignable` 是一个 `type trait`（类型特征），C++11 提供了数十个这样的特征以便程序员在编译期询问类型的属性。

`enable_if` 元函数由 Boost 开创并成为 C++11 的一部分。一个大致合理的实现：

```cpp
template<bool B, typename T = void>
struct enable_if {}; // false 的情况：里面没有 type

template<typename T>
struct enable_if<true, T> { typedef T type; }; // type 是 T
```

SFINAE 的精确规则非常微妙而难以驾驭，但是在用户的不断压力下，它们在 C++11 的发展过程中变得越来越简单和通用。SFINAE 的一个附带收获是，它从内部显著改善了编译器，因为编译器必须能够从失败的模板实例化中进行无副作用的回退。这就大大阻止了编译器对非本地状态的使用。

### 4.5.2 元编程支持

二十一世纪的头十年对于 C++ 元编程来说有点像是无法无天的美国西部拓荒时代，新的技巧和应用在仅有基本模板机制支持的情况下被不断尝试。那些基本机制被反复使用到令人痛苦。错误信息可谓糟糕透顶，编译时间经常奇慢无比，编译器资源（如内存、递归深度和标识符长度）会轻易耗尽。同时，人们纷纷重新发现同样的问题，并重新发明一些基本技巧。显然，我们需要更好的支持。改进尝试采用了两条（至少理论上）互补的路径：

- **语言**：概念（[§6](06.md#6-概念)），编译期函数（[§4.2.7](#427-constexpr-函数)），lambda 表达式（[§4.3.1](#431-lambda-表达式)），模板别名（[§4.3.3](#433-别名)），以及更精确的模板实例化规范（[§4.5.1](#451-实现技巧)）。
- **标准库**：`tuple`（[§4.3.4](#434-tuple)），类型特征（[§4.5.1](#451-实现技巧)），以及 `enable_if`（[§4.5.1](#451-实现技巧)）。

遗憾的是，概念在 C++11（[§6.2](06.md#62-c0x-概念)）中失败了，这给（通常复杂得可怕而且容易出错的）权宜之计留下了生存空间，典型情况会涉及类型特征和 `enable_if`（[§4.5.1](#451-实现技巧)）。

### 4.5.3 `noexcept` 规约

起初的异常设计没有办法表明某个异常可能会从某函数中抛出。我仍然认为那才是正确的设计。为了让异常为 C++98 接纳，我们不得不加入异常规约，来列举一个函数会抛出那些异常 [Stroustrup 1993]。使用异常规约可选，并会在运行期进行检查。正如我担心的那样，这带来了维护的问题，在展开路径上对异常反复检查增加的运行期开销，还有源代码膨胀。在 C++11 中，异常规约被废弃 [Gregor 2010]，而到了 C++17，我们终于（一致同意）移除了异常规约这个特性。

一直有人希望能够在编译时检查函数会抛出什么异常。从类型理论的角度，在小规模程序中，在有高速编译器和对代码完全控制的情况下，那当然行得通。委员会一再拒绝这种想法，原因是它不能扩展到由数十（或更多）组织维护的百万行代码规模的程序上 [Stroustrup 1994]。参见（[§7.4](07.md#74-类型系统的支持)）。

没有异常规约，库实现者们就要面对一个性能问题：在许多重要场合，一个库实现者需要知道一个拷贝操作是否会抛异常。如果会，就必须拿到一份拷贝以避免留下一个无效对象（这样会违犯异常保证 [Stroustrup 1993]）。如果不会，我们可以直接写入到目标中。在这种场合，性能的差别可以非常显著，而最简单的异常规约 `throw()`，什么也不抛出，在此可以帮助判断。于是，在异常规约被弃之不用并最终从标准中移除的时候，我们基于 David Abrahams 和 Doug Gregor 的提案 [Abrahams et al. 2010; Gregor 2010; Gregor and Abrahams 2009] 引入了 `noexcept` 概念。

一个 `noexcept` 函数仍会被动态检查。例如：

```cpp
void do_something(int n) noexcept
{
    vector<int> v(n);
    // ...
}
```

如果 `do_something()` 抛异常，程序会被终止。这样操作恰好非常接近零开销，因为它简单地短路了通常的异常传播机制。参见（[§7.3](07.md#73-noexcept-规约)）。

还有一个条件版本的 `noexcept`，用它可以写出这样的模板，其实现依赖于某参数是否会抛异常。这是最初促成 `noexcept` 的用例。例如，下面代码中，当且仅当 `pair` 的两个元素都有不抛异常的移动构造函数时，`pair` 的移动构造函数才会声明不抛异常：

```cpp
template<typename First, typename Second>
class pair {
    // ...
    template <typename First2, typename Second2>
    pair(pair<First2, Second2>&& rhs)
        noexcept(is_nothrow_constructible<First, First2&&>::value
              && is_nothrow_constructible<Second, Second2&&>::value)
    : first(move(rhs.first)),
      second(move(rhs,second))
    {}
    // ...
};
```

其中的 `is_nothrow_constructible<>` 是 C++11 标准库的类型特征（type traits）之一（[§4.5.1](#451-实现技巧)）。

在这相对底层和非常通用的层级写出最优代码可不简单。在基础层面上，懂得到底该按位拷贝，该移动，还是该按成员拷贝，会带来非常大的区别。

## 4.6 C++11：标准库组件

C++ 跟其他现代语言比一直有个小巧的标准库。此外，大多标准库组件都很基础，而不是试图处理应用层面的任务。不过，C++11 增加了几个关键的库组件来支持特定任务：

- `thread`——基于线程和锁的并发
- `regex`——正则表达式
- `chrono`——时间
- `random`——随机数产生器和分布

和大量的商业支持程序库相比，这显然小得可怜，但这些组件质量很高，并且跟之前的标准 C++ 相比数量也多多了。

设计这些组件，是要服务于一些特定任务。在这些任务中，它们为程序员提供了重大帮助。遗憾的是，这些库来自不同背景，体现在接口风格上，就出现了差异；除了要灵活和高性能之外它们没有一致的整体设计哲学。C++11 在合入一个组件方面没有明晰的标准（C++98 有一些 [Stroustrup 1994]）。更准确地说，我们只是从现有的、已被社区证明成功的组件中接收组件进来。很多组件来自 Boost（[§2.3](02%20-%20背景：C++%20的%201979–2006.md#23-c-的-2006)）。

如果你需要使用正则表达式，标准库中新加入的 `regex` 就是个巨大改进了。类似，加入无序容器（哈希表），如 `unordered_map`，为很多程序员省去了大量繁琐的工作，使之可以产出更好的程序。然而，这些库组件并没有对人们组织代码的方式产生重大影响，所以我在此不对这些库组件的细节展开讨论。












[[enable_shared_from_this]]

`regex` 库主要是 John Maddock 的工作 [Maddock 2002]。

哈希表不巧错过了 C++98 的截止时间，因而出现在了 C++0x 的第一批提案之中 [Austern 2002]。它们被称做无序的（例如 `unordered_map`），是为了区别于老的、有序的标准容器（例如 `map`），也是因为较明显的名字（例如 `hash_map`）已经在 C++11 之前被其他库大量使用了。另外，`unordered_map` 也可以说是个更好的名字，因为它指出了类型提供什么，而不是它是如何实现的。

`random` 库提供了分布函数和随机数产生器，其复杂性被誉为“每个随机数库都想长成的样子”。但它对初学者或者一般用户（常需要随机数）并不易用。它在 2002 年由 Jens Maurer [Maurer 2002] 提出，并在 2006 年经由费米国家实验室的一群人修订 [Brown et al. 2006]，随即被接受。

相比之下，Howard Hinnant 的 `chrono` 库 [Hinnant et al. 2008] 处理时间点和时间间隔，在提供复杂功能的同时仍保持了易用性。例如：

```cpp
using namespace std::chrono;  // 在子命名空间 std::chrono
auto t0 = system_clock::now();
do_work();
auto t1 = system_clock::now();
cout << duration_cast<milliseconds>(t1-t0).count() << "msec\n";
```

其中的 `duration_cast` 把依赖于时钟的“嘀嗒”节拍数转换为程序员选用的时间单位。

使用如此简单的代码，你可以让大一学生都能感受到不同算法和数据结构的代价差异。`chrono` 为 `thread` 库提供了时间支持（[§4.1.2](#412-线程和锁)）。

到了 C++20，`chrono` 得到进一步增强，加入了处理日期和时区的功能（[§9.3.6](09.md#936-日期和时区)）。C++20 也允许把上面的例子简化为：

```cpp
cout << t1-t0 << '\n';
```

这就会把 `t0` 和 `t1` 之间的时间差自动以合适的单位进行输出。

[^1]: 译注：参考 Python 在 PEP 20—The Zen of Python 中的不同态度：“应该有且仅有一种明显的完成任务的方式（There should be one—and preferably only one—obvious way to do it）。”

[^2]: 译注：下面的代码引自 2006 年的论文，但 `operator=` 的实现不符合现代惯用法：一般要么把参数设为 `clone_ptr p`，这就成了一个可以同时适配拷贝或移动的通用赋值函数；要么在函数体内进行一次移动构造，先 `clone_ptr temp(std::move(p));` 再 `std::swap(ptr, temp.ptr);`。否则，当传递的实参是 `std::move` 的结果（xvalue）而不是真正的临时对象（prvalue）时，代码的行为会不符合预期。当然，就如下面 Bjarne 讨论到的，在 2006 年应该还没有 xvalue 和 prvalue 的概念。
