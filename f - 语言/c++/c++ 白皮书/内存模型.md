

当后来人们发现[[内存屏障]]和[[原子操作]]可以一起使用，创造出比单单使用其中之一更好的解决方案时，我和其他人都感到非常高兴。

稍后，我们增加了对基于数据依赖关系的一致性支持，通过[[属性]]在源代码中表示，比如 [[carries_dependency]]。

C++11 引入了 [[atomic]] 类型，上面的简单操作都是原子的：

```cpp
atomic<int> x;
void increment()
{
    x++;  // 不是 x = x + 1
}
```

显然，这些都是广泛有用的。例如，使用[[原子类型]]使出名棘手的[[双重检查锁定]]优化变得极为简单：

```cpp
mutex mutex_x;
atomic<bool> init_x;  // 初始为 false
int x;

if (!init_x) {
    lock_guard<mutex> lck(mutex_x);
    if (!init_x) x = 42;
    init_x = true ;
}  // 在此隐式释放 mutex_x（RAII）

// ... 使用 x ...
```

[[双重检查锁定]]的要点是使用相对开销低的 `atomic` 保护开销大得多的 `mutex` 的使用。

[[lock_guard]] 是一种 [[003 - RAII机制]]类型，它确保会解锁它所控制的 `mutex`。

Hans-J. Boehm 将原子类型描述为“令人惊讶地流行”，但我不能说我感到惊讶。我没 Hans 那么专业，对简化更为欣赏。C++11 还引入了用于[[无锁编程]]的关键运算，例如比较和交换：

```cpp
template<typename T>
class stack {
    std::atomic<node<T>*> head;
public:
    void push(const T& data)
    {
        node<T>* new_node = new node<T>(data);
        new_node->next = head.load(std::memory_order_relaxed);
        while(!head.compare_exchange_weak(new_node->next, new_node,
              std::memory_order_release, std::memory_order_relaxed)) ;
    }
    // ...
};
```

即使有了 C++11 的支持，我仍然认为无锁编程是专家级的工作。