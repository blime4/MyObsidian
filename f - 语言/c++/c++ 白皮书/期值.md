期值（future）

C++11 提供了：

- [[future]]——一个句柄，通过它你可以从一个共享的单对象缓冲区中 `get()` 一个值，可能需要等待某个 `promise` 将该值放入缓冲区。
- [[promise]]——一个句柄，通过它你可以将一个值 `put()` 到一个共享的单对象缓冲区，可能会唤醒某个等待 `future` 的 `thread`。
- [[packaged_task]]——一个类，它使得设置一个函数在线程上异步执行变得容易，由 `future` 来接受 `promise` 返回的结果。
- [[async()]]——一个函数，可以启动一个任务并在另一个 `thread` 上执行。

使用这一切的最简单方法是使用 `async()`。给定一个普通函数作为参数，`async()` 在一个 `thread` 上运行它，处理线程启动和通信的所有细节：

```cpp
double comp4(vector<double>& v)
// 如果 v 足够大则会产生多个任务
{
    if (v.size()<10000)    // 值得用并发机制吗？
        return accum(v.begin(),v.end(),0.0);
    auto v0 = &v[0];
    auto sz = v.size();

    auto f0 = async(accum,v0,v0+sz/4,0.0);         // 第一部分
    auto f1 = async(accum,v0+sz/4,v0+sz/2,0.0);    // 第二部分
    auto f2 = async(accum,v0+sz/2,v0+sz*3/4,0.0);  // 第三部分
    auto f3 = async(accum,v0+sz*3/4,v0+sz,0.0);    // 第四部分

    return f0.get()+f1.get()+f2.get()+f3.get();    // 收集结果
}
```
`async` 将代码包装在 `packaged_task` 中，并管理 `future` 及其传输结果的 `promise` 的设置。

值或异常都可以通过这样一对 `future`/`promise` 从一个 `thread` 传递到另一个 `thread`。例如：

```cpp
X f(Y); // 普通函数

void ff(Y y, promise<X>& p)     // 异步执行 f(y)
{
    try {
        X res = f(y);           // ... 给 res 计算结果 ...
        p.set_value(res);
    }
    catch (...) {               // 哎呀：没能计算出 res
        p.set_exception(current_exception());
    }
}
```

为简单起见，我没有使用参数的[[完美转发]]

对应 `future` 的 `get()` 现在要么得到一个值，要么抛出一个异常——与 `f()` 的某个等效同步调用完全一样。

```cpp
void user(Y arg)
{
    auto pro = promise<X>{};
    auto fut = pro.get_future();
    thread t {ff,arg,ref(pro)}; // 在不同线程上运行 ff
    // ... 做一会别的事情 ...
    X x = fut.get();
    cout << x.x << '\n';
    t.join();
}

int main()
{
    user(Y{99});
}
```

标准库的 `packaged_task` 自动化了这个过程，可以将普通函数包装成一个函数对象，负责 `promise`/`future` 的自动配置并处理返回和异常。
