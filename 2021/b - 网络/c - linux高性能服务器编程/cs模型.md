![[Pasted image 20220102001334.png]]

C/S模型的逻辑很简单。

服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。

服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。

由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。
I/O模型有多种，图8-2中，服务器使用的是I/O复用技术之一的[[select]]系统调用。

当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。

逻辑单元可以是新创建的子进程、子线程或者其他。图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。至此，双方的通信结束。需要注意的是，服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客户的请求，才能继续处理下一个客户请求）

图8-2中，服务器同时监听多个客户请求是通过select系统调用实现的。

![[Pasted image 20220102001630.png]]


缺点：

C/S模型非常适合资源相对集中的场合，并且它的实现也很简单，但其缺点也很明显：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。下面讨论的P2P模型解决了这个问题。