# 002 - zeromq源码分析笔记之架构

# 1、zmq概述
ZeroMQ是一种基于消息队列的多线程网络库，其对套接字类型、连接处理、帧、甚至路由的底层细节进行抽象，提供跨越多种传输协议的套接字。引用[云风](http://blog.codingnow.com/2011/02/zeromq_message_patterns.html)的话来说:ZeroMQ 并不是一个对 socket 的封装，不能用它去实现已有的网络协议。它有自己的模式，不同于更底层的点对点通讯模式。它有比 tcp 协议更高一级的协议。（当然 ZeroMQ 不一定基于 TCP 协议，它也可以用于进程间和进程内通讯）它改变了通讯都基于一对一的连接这个假设。ZeroMQ 把通讯的需求看成四类。其中一类是一对一结对通讯，用来支持传统的 TCP socket 模型，但并不推荐使用。常用的通讯模式只有三类：

1.  [[请求回应模型]]。由请求端发起请求，并等待回应端回应请求。从请求端来看，一定是一对对收发配对的；反之，在回应端一定是发收对。请求端和回应端都可以是 1:N 的模型。通常把 1 认为是 server ，N 认为是 Client 。ZeroMQ 可以很好的支持路由功能（实现路由功能的组件叫作 Device），把 1:N 扩展为 N:M （只需要加入若干路由节点）。从这个模型看，更底层的端点地址是对上层隐藏的。每个请求都隐含有回应地址，而应用则不关心它。
2.  [[发布订阅模型]]。这个模型里，发布端是单向只发送数据的，且不关心是否把全部的信息都发送给订阅端。如果发布端开始发布信息的时候，订阅端尚未连接上来，这些信息直接丢弃。不过一旦订阅端连接上来，中间会保证没有信息丢失。同样，订阅端则只负责接收，而不能反馈。如果发布端和订阅端需要交互（比如要确认订阅者是否已经连接上），则使用额外的 socket 采用请求回应模型满足这个需求。
3.  [[管道模型]]。这个模型里，管道是单向的，从 PUSH 端单向的向 PULL 端单向的推送数据流。



# 2、zmq架构

## 2.1、zmq整体架构

zeromq几乎所有I/O操作都是异步的，每个zmq i/o 线程（与实际线程不同）都有与之绑定的Poller，Poller采用经典的Reactor模式实现，Poller根据不同操作系统平台使用不同的网络I/O模型（select、poll、epoll、devpoll、kequeue等）。在zeromq中，zmq_socket也被看成是一个zmq io线程。每个线程内含一个信箱，用于线程与线程间传递命令（后面会详细讲），在创建zmq io线程时，会把信箱句柄加到Poller中，用于监听是否有命令到达。当client端开始发起连接或者server端开始监听时，会在主线程创建zmq_connector或者zmq_listener，主线程使用zmq_socket的mailbox发送命令给io线程，将其绑定到io线程中，io线程会把zmq_connector或者zmq_listener含有的句柄加入Poller中，以侦听读写事件。Client端与Server端都是通过Session来管理连接和通信，一个session代表一次会话，每个Session都会关联到相应的读/写管道， 主线程收发消息只是分别从管道中读/写数据。Session并不实际跟kernel交换I/O数据，而是通过plugin到Session中的Engine来与kernel交换I/O数据。