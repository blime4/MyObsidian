

基本思路是，把IO操作（通常是写操作）通过[[blockingqueue]]交给别的线程去做，自己不必等待。

**例1:日志（logging）** 　在多线程服务器程序中，日志（logging）至关重要，本例仅考虑写log file的情况，不考虑log server。

**例2：memcached客户端** 假设我们用memcached来保存用户最后发帖的时间，那么每次响应用户发帖的请求时，程序里要去设置一下memcached里的值。这一步如果用同步IO，会增加延迟。
对于“设置一个值”这样的write-only idempotent操作，我们其实不用等memcached返回操作结果，这里也不用在乎set操作失败，那么可以借助多线程来降低响应延迟。比方说我们可以写一个多线程版的memcached的客户端，对于set操作，调用方只要把key和value准备好，调用一下asyncSet()函数，把数据往[[blockingqueue]]上一放就能立即返回，延迟很小。剩下的事就留给memcached客户端的线程去操心，而服务线程不受阻碍。


其实所有的网络[[写操作]]都可以这么异步地做，不过这也有一个**缺点，那就是每次asyncWrite()都要在线程间传递数据。其实如果TCP缓冲区是空的，我们就可以在本线程写完，不用劳烦专门的IO线程。[[Netty]]就使用了这个办法来进一步降低延迟。**	

