
[[Condition]]


[[互斥器]]（[[mutex]]）是加锁原语，用来排他性地访问共享数据，它不是等待原语。在使用mutex的时候，我们一般都会期望加锁不要阻塞，总是能立刻拿到锁。然后尽快访问数据，用完之后尽快解锁，这样才能不影响并发性和性能。

如果需要等待某个条件成立，我们应该使用[[条件变量]]（[[condition variable]]）。条件变量顾名思义是一个或多个线程等待某个布尔表达式为真，即等待别的线程“唤醒”它。条件变量的学名叫[[管程]]（[[monitor]]）。Java Object内置的wait()、notify()、notifyAll()是条件变量 。


```c++

muduo::MutexLock mutex;
muduo::Condition cond(mutex);
std::deque<int> queue;

int dequeue(){
    MutexLockGuard lock(mutex);
    while(queue.empty()){
        cond.wait();    // 这一步会原子性的unlock mutex 并进入等待，不会与enqueue死锁
        // wait()执行完毕时会自动重新加锁
        assert(!queue.empty());
        int top = queue.front();
        queue.pop_front();
        return top;
    }
}

void enqueue(int x){
    MutexLockGuard lock(mutex);
    queue.push_back(x);
    cond.notify();  // 可以移出临界区之外
}
```


上面的代码中必须用while循环来等待条件变量，而不能用if语句，原因是[[spurious wakeup]] 。这也是面试多线程编程的常见考点。

对于signal/broadcast端：

1．不一定要在mutex已上锁的情况下调用signal（理论上）。
2．在signal之前一般要修改布尔表达式。
3．修改布尔表达式通常要用mutex保护（至少用作full memory barrier）。
4．注意区分[[signal]]与[[broadcast]]：“broadcast通常用于表明状态变化，signal通常用于表示资源可用。（broadcast should generally be used to indicate state change rather than resource availability。） ”




上面的 dequeue ()/enqueue () 实际上实现了一个简单的容量无限的（unbounded）[[blockingqueue]] 


条件变量是非常底层的[[同步原语]]，很少直接使用，一般都是用它来实现高层的同步措施，如 BlockingQueue<T>或 [[CountDownLatch]]。