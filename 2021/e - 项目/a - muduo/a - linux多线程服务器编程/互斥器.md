
[[mutex]]

互斥器（mutex）  恐怕是使用得最多的同步原语，粗略地说，它保护了临界区，任何一个时刻最多只能有一个线程在此mutex划出的临界区内活动。单独使用mutex时，我们主要为了保护共享数据。我个人的原则是：


+ 用 [[003 - RAII机制]] 手法封装 mutex 的创建、销毁、加锁、解锁这四个操作。保证锁的生效期间等于一个作用域（scope），不会因异常而忘记解锁。
+ 只用非递归的 mutex（即[[不可重入]]的 mutex）。
+ 不手工调用lock()和unlock()函数，一切交给栈上的Guard对象的构造和析构函数负责。Guard对象的生命期正好等于临界区（分析对象在什么时候析构是C++程序员的基本功）。这样我们保证始终在同一个函数同一个scope里对某个mutex加锁和解锁。避免在foo()里加锁，然后跑到bar()里解锁；也避免在不同的语句分支中分别加锁、解锁。这种做法被称为[[Scoped Locking]] 
+ 在每次构造Guard对象的时候，思考一路上（调用栈上）已经持有的锁，防止因加锁顺序不同而导致死锁（deadlock）。由于Guard对象是栈上对象，看函数调用栈就能分析用锁的情况，非常便利。


次要原则有：

+ 不使用跨进程的 mutex，进程间通信只用 TCP sockets。
+ 加锁、解锁在同一个线程，线程 a 不能去 unlock 线程 b 已经锁住的 mutex（RAII 自动保证）。
+ 别忘了解锁（RAII 自动保证）。
+ 不重复解锁（RAII 自动保证）。
+ 必要的时候可以考虑用 PTHREAD_MUTEX_ERRORCHECK 来排错。
