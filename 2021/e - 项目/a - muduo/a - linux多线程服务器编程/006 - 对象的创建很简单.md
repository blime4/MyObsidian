




[[对象构造]]要做到[[线程安全]]，唯一的要求是在构造期间不要泄露 [[this 指针]]，即
+ 不要在构造函数中注册任何回调；
+ 也不要在构造函数中把 this 传给跨线程的对象
+ 即便在构造函数的最后一行也不行。

> 之所以这样规定，是因为在构造函数执行期间对象还没有完成初始化，如果this被泄露（escape）给了其他对象（其自身创建的子对象除外），那么别的线程有可能访问这个半成品对象，这会造成难以预料的后果。


![[Pasted image 20211210163417.png]]

![[Pasted image 20211210163507.png]]

这也说明，[[二段式构造]]——即构造函数+initialize ()——有时会是好办法，这虽然不符合 C++教条，但是多线程下别无选择。另外，既然允许二段式构造，那么构造函数不必主动抛异常，调用方靠 initialize () 的返回值来判断对象是否构造成功，这能简化错误处理。
即使构造函数的最后一行也不要泄露this，因为Foo有可能是个基类，基类先于派生类构造，执行完Foo::Foo()的最后一行代码还会继续执行派生类的构造函数，这时most-derived class的对象还处于构造中，仍然不安全。
相对来说，对象的构造做到线程安全还是比较容易的，毕竟曝光少，回头率为零。而析构的线程安全就不那么简单，这也是本章关注的焦点。

