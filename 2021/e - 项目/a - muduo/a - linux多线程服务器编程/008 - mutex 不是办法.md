

[[mutex]] 只能保证函数一个接一个地执行，考虑下面的代码，它试图用互斥锁来保护析构函数：（注意代码中的 (1) 和 (2) 两处标记。）
![[Pasted image 20211210165802.png]]
此时，有A、B两个线程都能看到Foo对象x，线程A即将销毁x，而线程B正准备调用x->update()。
![[Pasted image 20211210165818.png]]
尽管线程A在销毁对象之后把指针置为了NULL，尽管线程B在调用x的成员函数之前检查了指针x的值，但还是无法避免一种[[race condition]]：
1．线程A执行到了析构函数的(1)处，已经持有了互斥锁，即将继续往下执行。
2．线程B通过了if (x)检测，阻塞在(2)处。

这个例子至少说明delete对象之后把指针置为NULL根本没用，如果一个程序要靠这个来防止二次释放，说明代码逻辑出了问题。

==[[析构过程]]本来也不需要保护，==因为只有别的线程都访问不到这个对象时，析构才是安全的，否则会有谈到的[[竞态条件]]发生。

这里就引出了 [[shared_ptr]] 和 [[weak_ptr]]的必要性了。


另外如果要同时读写一个 class 的两个对象，有潜在的[[死锁]]可能。比方说有 swap () 这个函数：
![[Pasted image 20211210170227.png]]

如果线程 A 执行 swap (a, b); 而同时线程 B 执行 swap (b, a);，就有可能死锁。
