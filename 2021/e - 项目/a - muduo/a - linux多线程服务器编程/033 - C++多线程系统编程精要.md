
学习多线程编程面临的最大的思维方式的转变有两点：
·当前线程可能随时会被切换出去，或者说被[[抢占]]（[[preempt]]）了。
·多线程程序中事件的发生顺序不再有全局统一的先后关系 

  

当线程被切换回来继续执行下一条语句（指令）的时候，全局数据（包括当前进程在操作系统内核中的状态）可能已经被其他线程修改了。

在单CPU系统中，理论上我们可以通过记录CPU上执行的指令的先后顺序来推演多线程的实际交织（interweaving）运行的情况。在多核系统中，多个线程是并行执行的，我们甚至没有统一的全局时钟来为每个事件编号。在没有适当同步的情况下，多个CPU上运行的多个线程中的事件发生先后顺序是无法确定的，在引入适当同步后，事件之间才有了happens-before关系 。
多线程程序的正确性不能依赖于任何一个线程的执行速度，不能通过原地等待（sleep ()）来假定其他线程的事件已经发生，而必须通过适当的同步来让当前线程能看到其他线程的事件的结果。无论线程执行得快与慢（被操作系统切换出去得越多，执行越慢），程序都应该能正常工作。例如下面这段代码就有这方面的问题。


[[034 - 基本线程原语的选用]]
[[035 - c++系统库的线程安全性]]


·线程是宝贵的，一个程序可以使用几个或十几个线程。一台机器上不应该同时运行几百个、几千个用户线程，这会大大增加内核scheduler的负担，降低整体性能。

·线程的创建和销毁是有代价的，一个程序最好在一开始创建所需的线程，并一直反复使用。不要在运行期间反复创建、销毁线程，如果必须这么做，其频度最好能降到1分钟1次（或更低）。

·每个线程应该有明确的职责，例如 IO 线程（运行 EventLoop :: loop ()，处理 IO 事件）、计算线程（位于 ThreadPool 中，负责计算）等等。
·线程之间的交互应该尽量简单，理想情况下，线程之间只用消息传递（例如BlockingQueue）方式交互。如果必须用锁，那么最好避免一个线程同时持有两把或更多的锁，这样可彻底防止死锁。

·要预先考虑清楚一个 mutable shared 对象将会暴露给哪些线程，每个线程是读还是写，读写有无可能并发进行。