[[异步IO]]
[[DMA]]特性
[[模拟Proactor模式]]
[[两种高效的并发模式]]

![[capture-2021-12-09-16-32-55.png]]


1. 理论上[[proactor]]比[[reactor]]效率更高
2. 充分利用[[DMA ]]特性
3. [[boost asio]]实现的[[proactor]]，实际上并不是真正意义上的[[异步IO]],而是用[[epoll]]模拟实现的
4. 其实Linux目前没有比较成熟的[[异步IO]]服务器




使用异步I/O模型（以[[aio_read]]和[[aio_write]]为例）实现的Proactor模式的工作流程是：

1）主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册）。

2）主线程继续处理其他逻辑。

3）当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。

4）应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例）。

5）主线程继续处理其他逻辑。

6）当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。

7）应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。

图8-6总结了Proactor模式的工作流程。

![[Pasted image 20220102035245.png]]

连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。