【得分点】

智能指针解决的问题、内存泄露、4种智能指针、实现原理

【参考答案】

标准回答

1. 智能指针解决的问题

如果在程序中使用new 从堆（自由存储区）分配内存，等到不再需要时，应使用 delete 将其释放，如果忘记释放，则会产生内存泄露。C++ 引入了智能指针 auto_ptr（C++98）， 以帮助自动完成这个过程。智能指针是行为类似于指针的类对象。

2. 有哪些智能指针

C++ 中有 4 种智能指针：auto_ptr、unique_ptr、shared_ptr、weak_ptr。其中 auto_ptr 在 C++11 中被弃用，weak_ptr 需要配合 shared_ptr 使用，并不能算是真正的智能指针。

3. 智能指针实现原理

智能指针解决问题的思想：将常规指针进行包装，当智能指针对象过期时，让它的析构函数对常规指针进行内存释放。

auto_ptr（C++98的方案，C++11已经废弃）：采用所有权模式，对于特定的对象，只能有一个智能指针可拥有它，这样只有拥有对象的智能指针的析构函数会删除该对象。然后，让赋值操作转让所有权。

unique_ptr（替代 auto_ptr）：也是采用所有权模式，实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。

shared_ptr：采用引用计数实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在最后一个引用被销毁时候释放。它使用引用计数来表明资源被几个指针共享。例如，赋值时，计数将加 1，而指针过期时，计数将减 1。仅当最后一个指针过期时，才调用 delete。

weak_ptr：该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。weak_ptr 类型指针并不会影响所指堆内存空间的引用计数，可以用来解决循环引用问题。

加分回答

如何选择智能指针：

· 如果程序要使用多个指向同一个对象的指针，应该选择shared_ptr；

· 如果程序不需要多个指向同一个对象的指针，则可以使用unique_ptr;

· 如果使用new [] 分配内存，应该选择 unique_ptr;

· 如果函数使用new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。