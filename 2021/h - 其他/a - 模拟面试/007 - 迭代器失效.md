# 007 - 迭代器失效
- Date: 2022-01-06
- Time:  14:58


## 一、迭代器失效问题
迭代器的失效问题：对容器的操作影响了元素的存放位置，称为迭代器失效。
失效情况：
1. 当容器调用`erase()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
2. 当容器调用`insert()`方法后，当前位置到容器末尾元素的所有迭代器全部失效。
3. 如果容器`扩容`，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。
4. 不同容器的迭代器，是不能进行比较运算的。


### 失效问题1：
我们先使用库中的vector来看看什么是失效问题：把vec容器中所有的偶数全部删除
```c++

int main()
{
	vector<int>vec;
	for (int i=0; i<20; ++i)
	{
		vec.push_back(rand()%100 + 1);
	}

	//把vec容器中所有的偶数全部删除
	auto it = vec.begin();
	for (; it!=vec.end(); ++it)
	{
		if (*it % 2 == 0)
		{
			vec.erase(it);//insert(it,val) erase(it)
			break;//只删除第一个偶数
		}
	}

	return 0;
}

```
当我们调用vec.erase时加上break时候，程序执行成功。

但如果我们去掉break时候：程序崩溃，第一次调用erase后，迭代器it就失效了，再对其进行++运算符重载函数调用就崩溃了。
![[Pasted image 20220106150350.png]]

### 失效问题2：
给vec容器中所有的偶数前面添加一个小于偶数值1的数字
```c++
int main()
{
	vector<int>vec;
	for (int i=0; i<20; ++i)
	{
		vec.push_back(rand()%100 + 1);
	}

	//给vec容器中所有的偶数前面添加一个小于偶数值1的数字
	auto it = vec.begin();
	for (; it!=vec.end(); ++it)
	{
		if (*it % 2 == 0)
		{
			vec.insert(it, *it-1);
			break;
		}
	}
}


```

当我们调用`vec.insert`时加上break时候，程序执行成功。
但如果我们去掉break时候：程序崩溃。这里的迭代器在第一次insert之后，iterator就失效了，再执行运算符重载函数调用就崩溃了。



## 二、如何解决迭代器失效问题
**解决方案：对插入/删除点的迭代器进行更新操作。**

### 解决失效问题1：解决删除问题

```c++
//把vec容器中所有的偶数全部删除
auto it = vec.begin();
while (it!=vec.end())
{
	if (*it % 2 == 0)
	{
		it = vec.erase(it);//insert(it,val) erase(it)
        //更新当前删除位置迭代器
	}
	else
	{
		++it;
	}
}
```

### 解决失效问题2：解决增加问题
```c++
//给vec容器中所有的偶数前面添加一个小于偶数值1的数字
auto it = vec.begin();
for (; it!=vec.end(); ++it)
{
	if (*it % 2 == 0)
	{
		it = vec.insert(it, *it-1);//更新当前增加位置迭代器
		++it;
	}
}

```











[参考自：](https://blog.csdn.net/qq_42441693/article/details/104805190?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-5&spm=1001.2101.3001.4242)