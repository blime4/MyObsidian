
# 001 - 循环引用问题

```c++
class B;

class A {
 public:
  std::shared_ptr<B> b;
  ~A() { std::cout << "Destroy A\n"; }
};

class B {
 public:
  std::shared_ptr<A> a;
  ~B() { std::cout << "Destroy B\n"; }
};

int main() {
  {
    auto p = std::make_shared<A>();
    p->b = std::make_shared<B>();
    p->b->a = p;
    assert(p.use_count() == 2);
  }  // p 的引用计数由 2 减为 1，不会析构
     // 于是 p->b 也不会析构，导致两次内存泄漏
}
```


-   分析 [std::shared_ptr](https://en.cppreference.com/w/cpp/memory/shared_ptr) 的生命周期，适当使用 [std::weak_ptr](https://en.cppreference.com/w/cpp/memory/weak_ptr) 即可避免此类情况
```c++
class B;

class A {
 public:
  std::shared_ptr<B> b;
  ~A() { std::cout << "Destroy A\n"; }
};

class B {
 public:
  std::weak_ptr<A> a;
  ~B() { std::cout << "Destroy B\n"; }
};

int main() {
  {
    auto p = std::make_shared<A>();
    p->b = std::make_shared<B>();
    p->b->a = p;  // weak_ptr 不增加 shared_ptr 的引用计数
    assert(p.use_count() == 1);
  }  // Destroy A
     // Destroy B
}

```
