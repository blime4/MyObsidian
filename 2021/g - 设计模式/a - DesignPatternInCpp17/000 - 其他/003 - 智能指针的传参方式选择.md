# 003 - 智能指针的传参方式选择

* 以下两种传参方式，应该如何选择？

```cpp

void f(std::shared_ptr<A> p); // 按值传递

void f(const std::shared_ptr<A>& p); // 按 const 引用传递

```

* 不同的传参方式表达了不同的语义，通常情况下，按 const 引用传递是最稳妥且没有心智负担的

[[888 - 具体略过了，以后再学]] 这里感觉还是有点难
```cpp

void f(A&); // 仅使用对象，不涉及对象资源所有权的管理

void f(A*); // 仅使用对象，不涉及对象资源所有权的管理

  
void f(std::unique_ptr<A>); // 用于转移唯一所有权（用 std::move 传入）

void f(std::unique_ptr<A>&); // 用于重置内部对象

void f(const std::unique_ptr<A>&); // 不如直接传引用或原始指针

  
void f(std::shared_ptr<A>); // 引用计数共享

							 // 可用 std::move 传入 std::unique_ptr 实参


void f(std::shared_ptr<A>&); // 引用计数不变，用于重置内部对象
	
							 // 不可接受 std::unique_ptr 实参


void f(const std::shared_ptr<A>&); // 引用计数不变，不可重置内部对象

									 // 可用 std::move 传入 std::unique_ptr 实参

```

  

* 对于按值传递，只在之后一定会对其拷贝的场景才可能考虑使用

```cpp

void f(const std::shared_ptr<A>& p) {

 auto q = p; // 拷贝 p

 // ...

}

```

* 如果按值传递，拷贝可以改用移动，比起传引用后使用拷贝，只多出一次移动操作，如果移动开销很小，这种做法简化了代码，是一个很好的选择

  

```cpp

void f(std::shared_ptr<A> p) { // 拷贝一次

 auto q = std::move(p); // 移动一次

 // ...

}

```

  

* 这种情况常见于构造函数中

  

```cpp

class X {

 public:

 explicit X(std::shared_ptr<A> p) : p_(std::move(p)) {}

  

 private:

 std::shared_ptr<A> p_;

};

```