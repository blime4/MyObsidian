# [[move]]语义 与 [[结构化绑定]]


```c++
MyStruct ms = { 42, "Jim" };
auto&& [v, n] = std::move(ms);      // 匿 名 实 体 是ms的 右 值 引 用

```
这里 v 和 n 指向的匿名实体是 ms 的右值引用。同时 ms 的值仍然保持不变：
```c++
std::cout << "ms.s: " << ms.s << '\n'; // 打 印 出"Jim"
```

然而，你可以对指向 ms.s 的n 进行移动赋值：
```c++
std::string s = std::move(n);          // 把ms.s移 动 到s
std::cout << "ms.s: " << ms.s << '\n'; // 打 印 出 未 定 义 的 值
std::cout << "n: " << n << '\n';       // 打 印 出 未 定 义 的 值
std::cout << "s: " << s << '\n';       // 打 印 出"Jim"
```

像通常一样，值被移动走的对象处于一个值未定义但却有效的状态。因此可以打印它们的值，但不要对打印出的值有任何期望
> 对于 string 来说，值被移动走之后一般是处于空字符串的状态，但并不保证这一点


上面的例子和直接用 ms 被移动走的值进行结构化绑定有些不同：
![[Pasted image 20220114033223.png]]



