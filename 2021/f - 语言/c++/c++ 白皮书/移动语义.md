在 C 和 C++ 中，要从函数获得大量的数据，传统做法是在自由存储区（堆、动态内存）上分配空间，然后传递指向该空间的指针作为函数参数。比如，对于工厂函数和返回容器（例如 `vector` 和 `map`）的函数就需要如此。这对开发者来说看起来很自然，而且相当高效。不幸的是，它是显式使用指针的主要来源之一，导致了写法上的不便、显式的内存管理，以及难以查找的错误。

多年来，很多专家使用“取巧”的办法来解决这个问题：把句柄类作为简单数值（常称为**值类型**）来传递，例如：

```cpp
Matrix operator+(const Matrix&, const Matrix&);

void use(const Matrix& m1, const Matrix& m2)
{
    Matrix m3 = m1+m2;
    // ...
}
```

这里 `operator+` 让我们可以使用常规的数学记法，同时也是一个工厂函数返回大对象的示例。

通过 `const` 引用把 `Matrix` 传递给函数，一直是传统而高效的做法。而问题在于，如何以传值来返回 `Matrix` 而不用拷贝所有的元素。早在 1982 年，我曾通过一种优化方案来部分解决这一问题，即干脆将返回值分配在调用函数的栈帧上。它工作得很好，但它只是优化技术，不能处理更复杂的返回语句。而用户在按值返回“大对象”时，需要确保绝不会进行大量的数据复制。

要做到这一点，需要观察到“大对象”通常是在自由存储区上的数据的一个句柄。为了避免复制大量的数据，我们只需要确保在实现返回时，构造函数复制的只是句柄，而不是所有元素。C++11 对这个问题的解决方案如下所示：

```cpp
class Matrix {
    double* elements;    // 指向所有元素的指针
    // ...
public:
    Matrix (Matrix&& a)  // 移动构造
    {
        elements = a.elements;  // 复制句柄
        a.elements = nullptr;   // 现在 a 的析构函数不用做任何事情了
    }
    // ...
};
```

当用于初始化或赋值的源对象马上就会被销毁时，**移动**就比**拷贝**要更好：移动操作只是简单地把对象的内部表示“窃取”过来。`&&` 表示构造函数是一个**移动构造函数**，`Matrix&&` 被称为**右值引用**。当用于模板参数时，右值引用的符号 `&&` 被叫做**转发引用**，这是由 John Spicer 在 2002 年的一次会议上，同 Dave Abrahams 和 Howard Hinnant 一起提出的。

这个 `Matrix` 的例子有个有意思的地方：如果 `Matrix` 的加法返回指针的话，那传统的数学记号（`a+b`）就不能用了。

移动语义蕴含着性能上的重大好处：它消除了代价高昂的临时变量。例如：

```cpp
Matrix mx = m1+m2+m3;  // 不需要临时变量
string sx = s1+s2+s3;  // 不需要临时变量
```

这里我添加了 `string` 的例子，因为移动语义立刻就被添加到了所有的标准库容器上，这可以让一些 C++98 的程序拿来不做任何代码修改就获得性能提升。

允许类的设计者定义移动操作后，我们就有了完整的对对象生命周期和资源管理的控制，这套控制始于 1979 年对构造函数和析构函数的引入。移动语义是 C++ 资源管理模型的重要基石 [Stroustrup et al. 2015]，正是这套机制使得对象能够在不同作用域之间可以简单而高效地进行移动。

早期对参数传递、完美转发和智能指针强调颇多，可能掩盖了这个重要的一般性观点。Howard Hinnant、Dave Abrahams 和 Peter Dimov 在 2002 年提出了移动语义的一般化版本 [Hinnant et al. 2004, 2002]：

> 右值引用可以用于给现有类方便地添加移动语义。意思是说，拷贝构造函数和赋值运算符可以根据实参是左值还是右值来进行重载。当实参是右值时，类的作者就知道他拥有对该实参的唯一引用。

一个突出的例子是生成“智能指针”的工厂函数：

```cpp
template <class T, class A1>
std::shared_ptr<T> factory(A1&& a1)
{
    return std::shared_ptr<T>(new T(std::forward<A1>(a1)));
}
```

现已进入标准库的函数 `forward` 告诉编译器将实参视为右值引用，因此 `T` 的移动构造函数（而不是拷贝构造函数）会被调用，来窃取该参数。它本质上就是个右值引用的类型转换。

在 C++98 中，没有右值引用，这样的“智能指针”很难实现。在 C++11 中，解决方案就简单了 [Hinnant et al. 2006]：[^2]

```cpp
template <class T>
class clone_ptr
{
private:
    T* ptr;
public:
    // ...
    clone_ptr(clone_ptr&& p)            // 移动构造函数
        : ptr(p.ptr)    // 拷贝数据的表示
    {
        p.ptr = 0;      // 把源数据的表示置空
    }
    clone_ptr& operator=(clone_ptr&& p) // 移动赋值
    {
        std::swap(ptr, p.ptr);
        return *this;   // 销毁目标的旧值
    }
};
```

很快，移动语义技术就被应用到了标准库的所有容器类上，像 `vector`、`string` 和 `map`。`shared_ptr` 和 `unique_ptr` 的确智能，但它们仍然是指针。我更喜欢强调移动构造和移动赋值，它们使得（以句柄表示的）大型对象在作用域间能够高效移动。

右值引用的提案在委员会中涉险过关。有人认为右值引用和移动语义多半来不及进入 C++11，因为这些概念很新，而我们那时连合适的术语都没有。部分由于术语上的问题 [Miller 2010]，**右值引用**这一术语在核心语言和标准库中的使用就有了分歧，从而使得标准草案中出现了不一致。在 2010 年 3 月的匹兹堡会议上，我参与了核心工作组（CWG）的讨论，在午饭休息的时间，在我看来“我们陷入了僵局，或者混乱之中，也许兼而有之”。我没有去吃午饭，而是对问题进行了分析，并得出结论，这里只涉及到两个基本概念：**有标识符**（identity），及**可被移动**。从这两个原语出发，我推导出了传统的左值和右值类别 [Barron et al. 1963]，以及解决我们的定义问题所需要的三个新类别。在核心工作组回来之后，我提出了我的解决方案。它很快就得到了接受，这样我们就在 C++11 中保留了移动语义 [Stroustrup 2010a]。