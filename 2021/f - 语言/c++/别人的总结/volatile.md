# volatile



volatile的作用： 作为指令关键字，确保本条指令不会因编译器的优化而省略，且要求每次直接读值。简单地说就是防止编译器对代码进行优化

当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，而不是使用保存在寄存器中的备份。即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

多线程下寄存器内的值可能为多个线程共享，可能会发生改变。


[B站视频：](https://www.bilibili.com/video/BV1fS4y1X7qb)CPU视角

例子1：

```c++
//file_A.cpp
int a = 0;
int task_A(){
	while(a>1){
		//do something
	}
	return 1;
}

//file_B.cpp
//extern int a;

void task_B(){
	a = 2;
}
```

如果认为a是常量0，优化掉file_A.cpp的整个while循环，就会出问题

例子2：

在做驱动开发的时候，需要读取一个寄存器，来了解usb设备的插拔状态，可在编译器眼里你就是在读一个没有变化的变量，于是它干脆不读寄存器，直接把立即数返回，这样usb的状态会一直不变，没有意义。

这种情况，防止编译器将变量当作常量优化掉，所以必须使用volatile
