给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

示例 1:
> 输入: [2,3,-2,4]
> 输出: 6
> 解释: 子数组 [2, 3] 有最大乘积 6。

## 思路：
[[53. 最大子数组和]]

不同的是，需要考虑负负得正的情况，需要需要保存负数的最小值

## 代码
```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> maxDp(n), minDp(n);
        maxDp[0] = nums[0];
        minDp[0] = nums[0];
        int ans = nums[0];
        for(int i = 1; i < n; ++i){
            maxDp[i] = max(maxDp[i-1]*nums[i], max(nums[i], minDp[i-1]*nums[i]));
            minDp[i] = min(minDp[i-1]*nums[i], min(nums[i], maxDp[i-1]*nums[i]));
            ans = max(maxDp[i] , ans);
        }
        return ans;
    }
};

```

## 代码优化 （滚动数组）

```c++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int maxDp = nums[0], minDp = nums[0], ans = nums[0];

        for(int i = 1 ; i < n; ++i){
            int mx = maxDp, mn = minDp;
            maxDp = max(mx*nums[i], max(nums[i], mn*nums[i]));
            minDp = min(mn*nums[i], min(nums[i], mx*nums[i]));
            ans = max(ans, maxDp);
        }

        return ans;
    }
};

```