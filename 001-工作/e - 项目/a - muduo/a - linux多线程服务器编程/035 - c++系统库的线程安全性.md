

由此可见，编写线程安全程序的一个难点在于线程安全是不可组合的（composable，一个函数foo()调用了两个线程安全的函数，而这个foo()函数本身很可能不是[[线程安全]]的。即便现在大多数glibc库函数是线程安全的，我们也不能像写单线程程序那样编写代码。


例子：
C++标准库中的绝大多数泛型算法是线程安全的 、因为这些都是无状态纯函数。只要输入区间是线程安全的，那么泛型函数就是线程安全的。

C++的iostream不是线程安全的，因为流式输出
```c++
std::cout<<"Now is"<<time(NULL);
```

等价于两个函数调用
```c++

std::cout.operator<<("Now is")
		 .operator<<(time(NULL));
```

即便 ostream :: operator<<() 做到了线程安全，也不能保证其他线程不会在两次函数调用之前向 stdout 输出其他字符。
对于“线程安全的 stdout 输出”这个需求，我们可以改用 printf，以达到安全性和输出的原子性。但是这等于用了[[全局锁]]，任何时刻只能有一个线程调用 printf，恐怕不见得高效。