
# 值语义

值语义（value semantics）指的是对象的拷贝与原对象无关 ，就像拷贝 int 一样。C++的内置类型（bool/int/double/char）都是值语义，标准库里的 complex<>、pair<>、vector<>、map<>、string 等等类型也都是值语意，拷贝之后就与原对象脱离关系。Java 语言的 primitivetypes 也是值语义。

与值语义对应的是“对象语义（objectsemantics）”，或者叫做引用语义（referencesemantics）

[[对象语义]]指的是面向对象意义下的对象，对象拷贝是禁止的。例如 muduo 里的 Thread 是对象语义，拷贝 Thread 是无意义的，也是被禁止的：因为 Thread 代表线程，拷贝一个 Thread 对象并不能让系统增加一个一模一样的线程。

> 同样的道理，拷贝一个 Employee 对象是没有意义的，一个雇员不会变成两个雇员，他也不会领两份薪水。拷贝 TcpConnection 对象也没有意义，系统中只有一个 TCP 连接，拷贝 TcpConnection 对象不会让我们拥有两个连接。Printer 也是不能拷贝的，系统只连接了一个打印机，拷贝 Printer 并不能凭空增加打印机。凡此总总，面向对象意义下的“对象”是 non-copyable。

C++中的值语义对象也可以是 mutable，比如 complex<>、pair<>、vector<>、map<>、string 都是可以修改的。muduo 的 InetAddress 和 Buffer 都具有值语义，它们都是可以修改的。

值语义的对象不一定是 [[POD]]，例如 string 就不是 POD，但它是值语义的。
> POD 类型是 C++中常见的概念，用来说明类/结构体的属性，具体来说它是指没有使用面相对象的思想来设计的类/结构体。POD 的全称是 Plain Old Data，Plain 表明它是一个普通的类型，没有虚函数虚继承等特性；Old 表明它与 C 兼容。

值语义的对象不一定小，例如 vector<int>的元素可多可少，但它始终是值语义的。当然，很多值语义的对象都是小的，例如 complex<>、muduo :: Date、muduo :: Timestamp。
	

值语义带来的好处是：[[memory locality]]

比方说我们在C++里定义
	complex<double> class，
	array ofcomplex<double>，
	vector<complex<double> >，
它们的layout如图所示。（re和im分别是复数的实部和虚部。）
	![[Pasted image 20211220125748.png]]
	
而如果我们在Java里干同样的事情，layout大不一样，memory locality也差很多
	![[Pasted image 20211220125826.png]]
在Java中每个object都有head，在常见的JVM中至少有两个word的开销。对比Java和C++，可见C++的对象模型要紧凑得多。
	
## 总结：
在新写一个 class 的时候，先想清楚它是值语义还是对象语义。一般来说，一个项目里只有少量的 class 是值语义，比如一些 snapshot 的数据，而大多数 class 都是对象语义。如果是对象语义的 class，那么应该立刻继承 boost :: noncopyable，防止编译器自动生成的拷贝构造函数和赋值操作符在无意中破坏程序行为。