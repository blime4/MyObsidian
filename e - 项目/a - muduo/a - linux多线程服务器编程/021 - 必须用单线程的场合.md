
据我所知，有两种场合必须使用单线程：

1．程序可能会fork(2)；
2．限制程序的CPU占用率。

**[[只有单线程程序能fork]](2)** 　一个设计为可能调用fork(2)的程序必须是单线程的，比如“[[看门狗进程]]”。多线程程序不是不能调用fork(2)，而是这么做会遇到很多麻烦，我想不出做的理由。

一个程序fork(2)之后一般有两种行为：

1．立刻执行exec()，变身为另一个程序。例如shell和inetd；又比如lighttpd fork()出子进程，然后运行fastcgi程序。或者集群中运行在计算节点上的负责启动job的守护进程（即我所谓的“看门狗进程”）。

2．不调用exec()，继续运行当前程序。要么通过共享的文件描述符与父进程通信，协同完成任务；要么接过父进程传来的文件描述符，独立完成工作，例如20世纪80年代的Web服务器NCSA httpd。

这些行为中，我认为==只有“看门狗进程”必须坚持单线程，其他的均可替换为多线程程序（从功能上讲）。==

**单线程程序能限制程序的CPU占用率** 　这个很容易理解，比如在一个8核的服务器上，一个单线程程序即便发生busy-wait（无论是因为bug，还是因为overload），占满1个core，其CPU使用率也只有12.5％.在这种最坏的情况下，系统还是有87.5％的计算资源可供其他服务进程使用。

因此对于一些辅助性的程序，如果它必须和主要服务进程运行在同一台机器的话（比如它要监控其他服务进程的状态），那么做成单线程的能避免过分抢夺系统的计算资源。比方说如果要把生产服务器上的日志文件压缩后备份到 NFS 上，那么应该使用普通单线程压缩工具（[[gzip]]/[[bzip2]]）。它们对系统造成的影响较小，在 8 核服务器上最多占满 1 个 core。如果有人为了“提高速度”，开启了多线程压缩或者同时起多个进程来压缩多个日志文件，有可能造成的结果是非关键任务耗尽了 CPU 资源，正常客户的请求响应变慢。这是我们不愿意看到的。

[[022 - 单线程程序的优缺点]]