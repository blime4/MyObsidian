涉及网络，高性能的框架，都会用到零拷贝


它是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域，这种技术通常用于通过网络传输文件时节省CPU周期和内存带宽。
通俗易懂来讲，零拷贝就是一种避免CPU将数据从一块存储拷贝到另一块存储的技术。零拷贝技术可以减少拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效的提高数据传输效率。


[[DMA]]
DMA：把磁盘的数椐栲贝到内核的缓中区里
read：系统调用的过程中会杷内核缓冲区的数据考贝到用户的缓中区里
write：操作系统直接将内核缓冲区的数椐栲贝到 socket缓中区中
CPU杷内核缓冲区里的数椐栲贝到 socket缓冲区的过程。


# 普通IO：

[[文件读写缓冲区]]
[[用户空间缓冲区]]
[[socket套接字缓冲区]]
![[Pasted image 20211223215943.png]]

read 会导致，从两次上下文切换，用户->内核 内核->用户
write同理

[[DMA]]拷贝是不需要经过cpu的


# [[mmap]] 优化：
上下文切换的次数不变，但是可以减少拷贝次数

![[Pasted image 20211223220345.png]]


# Linux 2.1 [[sendFile]]

直接从磁盘-》文件读写缓冲区-》套接字发送缓冲区-》网络设备缓冲区
跳过了文件读写缓冲区到用户空间（应用进程）缓冲区。
减少了两次上下文切换
![[Pasted image 20211223220547.png]]
# Linux 2.4 sendFile

![[Pasted image 20211223220521.png]]

# [[mmap]]和 [[sendfile]]的区别

1、mmap适合小数据量读写， sendfile适合大文件传输。
2、mmap需要4次上下文切换，3次数据拷贝； sendfile需要两次次上下文切换，两次数据拷贝
3、sendfile可以利用DMA方式，减少CPU拷贝，mmap则不能（必须从内核拷贝到Socket缓冲区）。


# sendfile 缺点
send file只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。有的场景下，需要将数据从一个套接字直接拷贝到另一个套接字，例如代理服务器，这种场景下， send file无法满足需求。


# [[splice]]
Linux在2.617版本引入 splice系统调用，用于在两个文件描述符中移动数据。

[[todo]]





从 Linux内核2.4版本开始起，对于支椅网卡支持SG-DMA技术的情况下，
第一步，通过DMA将磁盘上的数椐栲贝到内核缓冲区里
第二步，缓冲区描述符和数据长度传到 socket缓冲区，
这样网卡的SG-DMA控制器就可以直接将内核缓存中的数据栲贝到网卡的缓冲区里，
此过程不需要将数椐从操作系统内核缓冲区拷贝到 socket缓冲区中，这样就瑊少了一次数据拷贝

![[Pasted image 20211228163726.png]]