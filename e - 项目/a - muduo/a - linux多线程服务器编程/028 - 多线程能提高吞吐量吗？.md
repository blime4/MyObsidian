对于计算密集型服务，不能。

假设有一个耗时的计算服务，用单线程算需要0.8s。在一台8核的机器上，我们可以启动8个线程一起对外服务（如果内存够用，启动8个进程也一样）。这样完成单个计算仍然要0.8s，但是由于这些进程的计算可以同时进行，理想情况下吞吐量可以从单线程的1.25qps（query per second）上升到10qps。（实际情况可能要打个八折——如果不是打对折的话。）

假如改用并行算法，用8个核一起算，理论上如果完全并行，加速比高达8，那么计算时间是0.1s，吞吐量还是10qps，但是首次请求的响应时间却降低了很多。实际上根据Amdahl's law，即便算法的并行度高达95％，8核的加速比也只有6，计算时间为0.133s，这样会造成吞吐量下降为7.5qps。不过以此为代价，换得响应时间的提升，在有些应用场合也是值得的。


为了在并发请求数很高时也能保持稳定的吞吐量，我们可以用[[线程池]]，线程池的大小应该满足“[[阻抗匹配原则]]”

线程池也不是万能的，如果响应一次请求需要做比较多的计算（比如计算的时间占整个response time的1/5强），那么用线程池是合理的，能简化编程。如果在一次请求响应中，主要时间是在等待IO，那么为了进一步提高吞吐量，往往要用其他编程模型，比如[[Proactor]]