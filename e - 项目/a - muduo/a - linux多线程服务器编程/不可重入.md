****



Mutex 分为递归（recursive）和非递归（non-recursive）两种，这是 POSIX 的叫法，另外的名字是[[可重入]]（[[reentrant]]）与[[非可重入]]。这两种 mutex 作为线程间（inter-thread）的同步工具时没有区别，它们的唯一区别在于：同一个线程可以重复对 [[recursive mutex]] 加锁，但是不能重复对 [[non-recursive mutex]] 加锁。


==首选非递归mutex==，绝对不是为了性能，而是为了体现设计意图。non-recursive和recursive的性能差别其实不大，因为少用一个计数器，前者略快一点点。
在同一个线程里多次对non-recursive mutex加锁会立刻导致死锁，我认为这是它的优点，能帮助我们思考代码对锁的期求，并且及早（在编码阶段）发现问题。


毫无疑问recursive mutex使用起来要方便一些，因为不用考虑一个线程会自己把自己给锁死了，我猜这也是Java和Windows默认提供recursive mutex的原因。（Java语言自带的intrinsic lock是可重入的，它的util.concurrent库里提供ReentrantLock，Windows的CRITICAL_SECTION也是可重入的。似乎它们都不提供轻量级的non-recursive mutex。）

==正因为它方便，recursive mutex可能会隐藏代码里的一些问题。典型情况是你以为拿到一个锁就能修改对象了，没想到外层代码已经拿到了锁，正在修改（或读取）同一个对象呢。==