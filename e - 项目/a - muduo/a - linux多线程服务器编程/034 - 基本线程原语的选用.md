11个最基本的Pthreads函数是：

2个：线程的创建和等待结束（join）。封装为muduo::[[Thread]]。
4个：mutex的创建、销毁、加锁、解锁。封装为muduo::[[MutexLock]]。
5个：条件变量的创建、销毁、等待、通知、广播。封装为muduo::[[Condition]]。
这些封装class都很直截了当，加起来也就一两百行代码，却已经构成了多线程编程的全部必备原语。用这三样东西（thread、mutex、condition）可以完成任何多线程编程任务。当然我们一般也不会直接使用它们（mutex除外），而是使用更高层的封装，例如mutex::[[ThreadPool]]和mutex::[[CountDownLatch]]等，见第2章。

除此之外，Pthreads还提供了其他一些原语，有些是可以酌情使用的，有些则是不推荐使用的。可以酌情使用的有：

·pthread_once，封装为muduo::[[Singleton]]<T>。其实不如直接用全局变量。

·pthread_key*，封装为muduo::[[ThreadLocal]]<T>。可以考虑用__thread替换之。不建议使用：

·[[pthread_rwlock]]，读写锁通常应慎用。muduo没有封装读写锁，这是有意的。

·sem_*，避免用信号量（semaphore）。它的功能与条件变量重合，但容易用错。

·pthread_{cancel, kill}。程序中出现了它们，则通常意味着设计出了问题。

  

**不推荐使用读写锁的原因是它往往造成提高性能的错觉（允许多个线程并发读），实际上在很多情况下，与使用最简单的mutex相比，它实际上降低了性能。另外，写操作会阻塞读操作，如果要求优化读操作的延迟，用读写锁是不合适的。
**
多线程系统编程的难点不在于学习线程原语（primitives），而在于理解多线程与现有的C/C++库函数和系统调用的交互关系，以进一步学习如何设计并实现线程安全且高效的程序。