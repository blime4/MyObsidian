---
doc_type: weread-highlights-reviews
bookId: "30179184"
author: 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
cover: https://cdn.weread.qq.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg
reviewCount: 9
noteCount: 62
readingStatus: 在读
progress: 36%
totalReadDay: 16
readingTime: 7小时2分钟
readingDate: 2021-12-19
isbn: 9787115508232
lastReadDate: 2023-07-25

---
# 元数据
> [!abstract] 操作系统导论
> - ![ 操作系统导论|200](https://cdn.weread.qq.com/weread/cover/71/YueWen_30179184/t7_YueWen_30179184.jpg)
> - 书名： 操作系统导论
> - 作者： 雷姆兹·H.阿帕希杜塞尔 安德莉亚·C.阿帕希杜塞尔
> - 简介： 这是一本关于现代操作系统的书。全书围绕虚拟化、并发和持久性这3个主要概念展开，介绍了所有现代系统的主要组件（包括调度、虚拟内存管理、磁盘和I/O子系统、文件系统 ）。 本书共50章，分为3个部分，分别讲述虚拟化、并发和持久性的相关内容。本书大部分章节均先提出特定的问题，然后通过书中介绍的技术、算法和思想来解决这些问题。笔者以对话形式引入所介绍的主题概念，行文诙谐幽默却又鞭辟入里，力求帮助读者理解操作系统中虚拟化、并发和持久性的原理。 本书内容全面，并给出了真实可运行的代码（而非伪代码），还提供了相应的练习，适合高等院校相关专业教师教学和高校学生自学。
> - 出版时间 2019-06-01 00:00:00
> - ISBN： 9787115508232
> - 分类： 计算机-计算机综合
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/db8329d071cc7f70db8a479

# 高亮划线

### 第4章 抽象：进程

> 📌 时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。 
> ⏱ 2023-05-30 20:37:21 ^30179184-11-1323-1412

> 📌 因此进程可以访问的内存（称为地址空间，address space）是该进程的一部分。 
> ⏱ 2023-05-30 20:40:24 ^30179184-11-2003-2045

> 📌 类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。 
> ⏱ 2023-05-30 20:43:32 ^30179184-11-2228-2292

> 📌 在许多操作系统中，一个通用的设计范式是将高级策略与其低级机制分开 
> ⏱ 2023-05-30 20:49:19 ^30179184-11-2366-2398

> 📌 miscellaneous control 
> ⏱ 2023-05-30 21:33:36 ^30179184-11-3247-3277

> 📌 操作系统也可能为程序的堆（heap）分配一些内存。在C程序中，堆用于显式请求的动态分配数据。程序通过调用malloc()来请求这样的空间，并通过调用free()来明确地释放它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随着程序运行，通过malloc()库API请求更多内存，操作系统可能会参与分配更多内存给进程，以满足这些调用。 
> ⏱ 2023-05-30 22:38:22 ^30179184-11-4424-4603

> 📌 对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。 
> ⏱ 2023-05-30 22:48:28 ^30179184-11-7386-7479

> 📌 有时候人们会将存储关于进程的信息的个体结构称为进程控制块（Process Control Block，PCB），这是谈论包含每个进程信息的C结构的一种方式。 
> ⏱ 2023-05-30 23:21:55 ^30179184-11-9386-9464

### 第5章 插叙：进程API

> 📌 子进程不会从main()函数开始执行（因此hello world信息只输出了一次），而是直接从fork()系统调用返回，就好像是它自己调用了fork()。 
> ⏱ 2023-06-01 09:20:13 ^30179184-12-2307-2384

> 📌 exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的p3）替换为不同的运行程序（wc）。子进程执行exec()之后，几乎就像p3.c从未运行过一样。对exec()的成功调用永远不会返回。 
> ⏱ 2023-06-01 09:42:42 ^30179184-12-6472-6660

> 📌 重定向的工作原理，是基于对操作系统管理文件描述符方式的假设。 
> ⏱ 2023-06-01 09:30:04 ^30179184-12-7828-7858

> 📌 具体来说，UNIX系统从0开始寻找可以使用的文件描述符。在这个例子中，STDOUT_FILENO将成为第一个可用的文件描述符，因此在open()被调用时，得到赋值。然后子进程向标准输出文件描述符的写入（例如通过printf()这样的函数），都会被透明地转向新打开的文件，而不是屏幕。 
> ⏱ 2023-06-01 09:30:30 ^30179184-12-7858-7999

> 📌 花时间阅读man手册是系统程序员成长的必经之路。 
> ⏱ 2023-06-01 09:44:12 ^30179184-12-9998-10022

### 第6章 机制：受限直接执行

> 📌 在构建这样的虚拟化机制时存在一些挑战。第一个是性能：如何在不增加系统开销的情况下实现虚拟化？第二个是控制权：如何有效地运行进程，同时保留对CPU的控制？控制权对于操作系统尤为重要，因为操作系统负责资源管理。如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。因此，在保持控制权的同时获得高性能，这是构建操作系统的主要挑战之一。 
> ⏱ 2023-06-01 09:57:06 ^30179184-13-509-685

> 📌 如果对运行程序没有限制，操作系统将无法控制任何事情，因此会成为“仅仅是一个库”——对于有抱负的操作系统而言，这真是非常令人悲伤的事！ 
> ⏱ 2023-06-01 10:00:19 ^30179184-13-1669-1735

> 📌 在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。 
> ⏱ 2023-06-01 10:04:51 ^30179184-13-2230-2356

> 📌 要执行系统调用，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。 
> ⏱ 2023-06-01 10:08:25 ^30179184-13-3011-3062

> 📌 完成后，操作系统调用一个特殊的从陷阱返回（return-from-trap）指令，如你期望的那样，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。 
> ⏱ 2023-06-01 10:09:04 ^30179184-13-3107-3190

> 📌 执行陷阱时，硬件需要小心，因为它必须确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回 
> ⏱ 2023-06-01 10:09:11 ^30179184-13-3203-3258

> 📌 内核通过在启动时设置陷阱表（trap table）来实现。当机器启动时，它在特权（内核）模式下执行，因此可以根据需要自由配置机器硬件。 
> ⏱ 2023-06-01 10:22:18 ^30179184-13-4125-4192

> 📌 时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。 
> ⏱ 2023-06-02 09:50:10 ^30179184-13-6933-7011

> 📌 时钟也可以关闭（也是特权操作），稍后更详细地理解并发时，我们会讨论。 
> ⏱ 2023-06-02 09:50:58 ^30179184-13-7398-7432

> 📌 都必须决定：是继续运行当前正在运行的进程，还是切换到另一个进程。这个决定是由调度程序（scheduler）做出的，它是操作系统的一部分。 
> ⏱ 2023-06-02 09:51:49 ^30179184-13-7703-7771

> 📌 为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换内核栈，供即将运行的进程使用。 
> ⏱ 2023-06-02 09:52:50 ^30179184-13-7997-8096

> 📌 通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程）的上下文。 
> ⏱ 2023-06-02 09:52:55 ^30179184-13-8096-8157

> 📌 操作系统这样做必须小心。禁用中断时间过长可能导致丢失中断，这（在技术上）是不好的。 
> ⏱ 2023-06-02 09:57:24 ^30179184-13-10949-10990

### 第7章 进程调度：介绍

> 📌 amortize 
> ⏱ 2023-06-02 10:09:32 ^30179184-14-8357-8365

> 📌 请注意，上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入，这可能导致显著的性能成本[MB91]。 
> ⏱ 2023-06-02 10:26:01 ^30179184-14-8675-8822

> 📌 我们介绍了调度的基本思想，并开发了两类方法。第一类是运行最短的工作，从而优化周转时间。第二类是交替运行所有工作，从而优化响应时间。但很难做到“鱼与熊掌兼得”，这是系统中常见的、固有的折中。 
> ⏱ 2023-06-03 21:57:51 ^30179184-14-11512-11606

> 📌 我们也看到了如何将I/O结合到场景中，但仍未解决操作系统根本无法看到未来的问题。稍后，我们将看到如何通过构建一个调度程序，利用最近的历史预测未来，从而解决这个问题。这个调度程序称为多级反馈队列，是第 8 章的主题。 
> ⏱ 2023-06-03 21:58:10 ^30179184-14-11606-11713

### 第8章 调度：多级反馈队列

> 📌 有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看man手册。 
> ⏱ 2023-06-03 22:31:31 ^30179184-15-8653-8744

### 第9章 调度：比例份额

> 📌 比例份额算法基于一个简单的想法：调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。 
> ⏱ 2023-06-04 23:45:43 ^30179184-16-451-512

### 第10章 多处理器调度（高级）

> 📌 由于本章内容相对较深，建议认真学习并发相关的内容后再读。 
> ⏱ 2023-06-05 20:51:17 ^30179184-17-423-451

> 📌 因此，建议不按顺序学习这些高级章节。对于本章，建议在学习完本书第2部分之后学习。 
> ⏱ 2023-06-05 20:52:15 ^30179184-17-1025-1065

> 📌 为了理解多处理器调度带来的新问题，必须先知道它与单CPU之间的基本区别。区别的核心在于对硬件缓存（cache）的使用（见图10.1），以及多处理器之间共享数据的方式。 
> ⏱ 2023-06-05 20:54:52 ^30179184-17-1454-1537

> 📌 缓存一致性（cache coherence）问题 
> ⏱ 2023-06-05 21:04:03 ^30179184-17-3005-3029

> 📌 或3门 
> ⏱ 2023-06-05 20:59:00 ^30179184-17-3093-3096

> 📌 硬件提供了这个问题的基本解决方案：通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性。 
> ⏱ 2023-06-05 21:04:04 ^30179184-17-3119-3171

> 📌 总线窥探 
> ⏱ 2023-06-05 21:04:04 ^30179184-17-3188-3192

> 📌 每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果CPU发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），或更新（update）它（修改为新值）。 
> ⏱ 2023-06-05 21:03:27 ^30179184-17-3212-3311

> 📌 尤其是性能方面。具体来说，随着CPU数量的增加，访问同步共享的数据结构会变得很慢。 
> ⏱ 2023-06-05 21:05:30 ^30179184-17-4626-4667

> 📌 这种调度中，A、B、C、D 这4个工作都保持在同一个CPU上，只有工作E不断地来回迁移（migrating），从而尽可能多地获得缓存亲和度。为了公平起见，之后我们可以选择不同的工作来迁移。但实现这种策略可能很复杂。 
> ⏱ 2023-06-05 21:09:37 ^30179184-17-6416-6523

> 📌 我们看到，SQMS调度方式有优势也有不足。优势是能够从单CPU调度程序很简单地发展而来，根据定义，它只有一个队列。然而，它的扩展性不好（由于同步开销有限），并且不能很好地保证缓存亲和度。 
> ⏱ 2023-06-05 21:09:52 ^30179184-17-6536-6629

> 📌 在MQMS中，基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则，比如轮转或其他任何可能的算法。当一个工作进入系统后，系统会依照一些启发性规则（如随机或选择较空的队列）将其放入某个调度队列。这样一来，每个CPU调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题。 
> ⏱ 2023-06-05 21:10:24 ^30179184-17-6825-6970

> 📌 所以可怜的多队列多处理器调度程序应该怎么办呢？怎样才能克服潜伏的负载不均问题，打败邪恶的……霸天虎军团[1]？ 
> ⏱ 2023-06-05 21:11:56 ^30179184-17-8651-8764

> 📌 BFS作为3个算法中唯一采用单队列的算法，也基于比例调度，但采用了更复杂的方案，称为最早最合适虚拟截止时间优先算法 
> ⏱ 2023-06-05 21:26:12 ^30179184-17-10663-10720

> 📌 构建一个通用的调度程序仍是一项令人生畏的任务，因为即使很小的代码变动，也有可能导致巨大的行为差异。除非很清楚自己在做什么，或者有人付你很多钱，否则别干这种事。 
> ⏱ 2023-06-05 21:27:10 ^30179184-17-10979-11058

> 📌 一个鲜为人知的事实是，变形金刚的家乡塞伯坦星球被糟糕的CPU调度决策所摧毁。 
> ⏱ 2023-06-05 21:12:00 ^30179184-17-13300-13338

### 第12章 关于内存虚拟化的对话

> 📌 有很多细节，你必须牢记它们，才能真正对发生的事情建立一个思维模型。我们将从简单的开始，使用诸如基址/界限等非常基本的技术，并慢慢增加复杂性以应对新的挑战，包括有趣的主题，如TLB和多级页表。最终，我们将能够描述一个全功能的现代虚拟内存管理程序的工作原理。 
> ⏱ 2023-06-05 21:37:03 ^30179184-19-868-995

### 第13章 抽象：地址空间

> 📌 利用栈（stack）来保存当前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。 
> ⏱ 2023-06-07 09:58:35 ^30179184-20-2505-2549

> 📌 堆（heap）用于管理动态分配的、用户管理的内存，就像你从C语言中调用malloc()或面向对象语言（如C ++或Java）中调用new 获得内存。 
> ⏱ 2023-06-07 09:58:45 ^30179184-20-2552-2626

### 第15章 机制：地址转换

> 📌 有时被称为基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）。 
> ⏱ 2023-06-15 09:58:32 ^30179184-22-1064-1144

> 📌 因此，在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。 
> ⏱ 2023-06-15 09:58:51 ^30179184-22-1245-1291

> 📌 我们可以用Linux的objdump或者Mac的otool将它反汇编： 
> ⏱ 2023-06-15 10:00:28 ^30179184-22-2289-2324

> 📌 在动态重定位的过程中，只有很少的硬件参与，但获得了很好的效果。一个基址寄存器将虚拟地址转换为物理地址，一个界限寄存器确保这个地址在进程地址空间的范围内。它们一起提供了既简单又高效的虚拟内存机制。 
> ⏱ 2023-06-15 10:07:24 ^30179184-22-5942-6039

> 📌 在上面的例子中，界限寄存器被置为16KB。如果进程需要访问超过这个界限或者为负数的虚拟地址，CPU将触发异常，进程最终可能被终止。界限寄存器的用处在于，它确保了进程产生的所有地址都在进程的地址“界限”中。 
> ⏱ 2023-06-15 10:08:17 ^30179184-22-6123-6225

> 📌 这种基址寄存器配合界限寄存器的硬件结构是芯片中的（每个CPU一对）。有时我们将CPU的这个负责地址转换的部分统称为内存管理单元（Memory Management Unit，MMU）。随着我们开发更复杂的内存管理技术，MMU也将有更复杂的电路和功能。 
> ⏱ 2023-06-15 10:08:26 ^30179184-22-6238-6363

> 📌 操作系统应该尽力保护它运行的机器，因此它不会对那些企图访问非法地址或执行非法指令的进程客气。再见了，行为不端的进程，很高兴认识你。 
> ⏱ 2023-06-15 10:22:58 ^30179184-22-9970-10035

### 第16章 分段

> 📌 但是，内存紧凑成本很高，因为拷贝段是内存密集型的，一般会占用大量的处理器时间 
> ⏱ 2023-07-10 09:57:48 ^30179184-23-7845-7883

> 📌 但遗憾的是，无论算法多么精妙，都无法完全消除外部碎片，因此，好的算法只是试图减小它。 
> ⏱ 2023-07-10 09:58:26 ^30179184-23-8143-8185

> 📌 它还很快，因为分段要求的算法很容易，很适合硬件完成，地址转换的开销极小。分段还有一个附加的好处：代码共享。如果代码放在独立的段中，这样的段就可能被多个运行的程序共享。 
> ⏱ 2023-07-17 10:06:14 ^30179184-23-8548-8631

### 第17章 空闲空间管理

> 📌 如果分配程序给出的内存块超出请求的大小，在这种块中超出请求的空间（因此而未使用）就被认为是内部碎片（因为浪费发生在已分配单元的内部），这是另一种形式的空间浪费。但是，简单起见，同时也因为它更有趣，这里主要讨论外部碎片。 
> ⏱ 2023-07-25 09:43:59 ^30179184-24-1968-2077

# 读书笔记

## 第5章 插叙：进程API

### 划线评论
> 📌 strdup("wc");  ^10284435-7IDDJWg8q
    - 💭 strdup("wc") 是一个动态分配内存的 C 函数，它将字符串 "wc" 复制到新分配的内存中，并返回一个指向该字符串副本的指针。
具体来说，strdup 函数会在堆上分配一块内存，大小足够容纳字符串 "wc"，然后将 "wc" 复制到该内存块中。最后，该函数返回一个指针，该指针指向新分配的内存块中的字符串副本。
注意，strdup 函数会自动为字符串结尾添加一个空字符 '\0'，因此返回的字符串也包括该空字符。
在这个例子中，strdup("wc") 返回的指针可以用于调用 execvp 函数，execvp 函数会在进程中执行名为 "wc" 的可执行文件。
    - ⏱ 2023-06-01 09:36:39

### 划线评论
> 📌 execvp(myargs[0], myargs);  ^10284435-7IDDSkVS8
    - 💭 execvp 函数是一个系统调用，它被用于在当前进程中执行一个新的程序。该函数需要两个参数：第一个参数是一个字符串，表示要执行的程序的路径或名称；第二个参数是一个字符串数组，表示要传递给新程序的命令行参数列表。
在 execvp(myargs[0], myargs) 中，myargs[0] 表示要执行的程序的名称，而 myargs 数组包含要传递给该程序的命令行参数。
该函数的行为如下：
1. 若调用成功，当前进程的代码和数据将被新程序替换，新程序将从 main 函数开始执行；
2. 若调用失败，当前进程将继续执行，execvp 函数会返回一个负值表示错误码。
需要注意的是，execvp 函数执行成功后，当前进程的代码和数据被替换，因此该函数后面的代码不会被执行。因此，如果我们想在调用 execvp 函数后执行一些操作，比如输出一些信息，需要将该操作放在子进程中进行。
    - ⏱ 2023-06-01 09:38:43

### 划线评论
> 📌 close(STDOUT_FILENO);  ^10284435-7IDDzwS5r
    - 💭 close(STDOUT_FILENO) 是一个系统调用，它关闭了当前进程的标准输出文件描述符（文件描述符 1）。这意味着在调用此函数后，该进程将无法向标准输出写入任何数据。
在标准的命令行环境中，用户的命令通常会将输出发送到标准输出，以便用户可以在屏幕上看到它。但是，在某些情况下，我们可能想要关闭标准输出，例如在某些程序中，我们不需要在屏幕上显示任何输出，或者我们想将输出重定向到其他地方。在这种情况下，我们可以使用 close(STDOUT_FILENO) 来关闭标准输出。
    - ⏱ 2023-06-01 09:34:05

### 划线评论
> 📌 阅读man手册可以避免尴尬。当你询问同事某个fork细节时，他可能会回复：“RTFM”。这是他在有礼貌地督促你阅读man手册（Read the Man）。RTFM中的F只是为这个短语增加了一点色彩……  ^10284435-7IDEkcZ39
    - 💭 哈哈哈哈，Read the fxxking man
和，FYI一样装逼是吧？
    - ⏱ 2023-06-01 09:45:35

### 划线评论
> 📌 有趣的是，你常常会发现top命令自己就是最占用资源的，它或许有一点自大狂。  ^10284435-7IDEx0zrx
    - 💭 笑死
    - ⏱ 2023-06-01 09:48:44
   
## 第10章 多处理器调度（高级）

### 章节评论 No.1
- 一个鲜为人知的事实是，变形金刚的家乡塞伯坦星球被糟糕的CPU调度决策所摧毁。 ^10284435-7IKsHxNfE
    - ⏱ 2023-06-05 21:14:47 
### 划线评论
> 📌 一个基本的方法是采用一种技术，名为工作窃取（work stealing）[FLR98]。通过这种方法，工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。  ^10284435-7IKt5rmX7
    - 💭 赛博卷王🌚
    - ⏱ 2023-06-05 21:20:41

### 划线评论
> 📌 自己去查BF代表什么  ^10284435-7IKtKwewc
    - 💭 🧠 brain fuck 
    - ⏱ 2023-06-05 21:30:48
   
## 第12章 关于内存虚拟化的对话

### 划线评论
> 📌 可能不希望。除非它是由你不喜欢的人编写的程序。
教授：嗯……我想可能需要在下个学期为你安排一门道德与伦理课程。也许操作系统课程没有传递正确的信息。  ^10284435-7IKuH8kw3
    - 💭 笑死
    - ⏱ 2023-06-05 21:45:14
   
# 本书评论
