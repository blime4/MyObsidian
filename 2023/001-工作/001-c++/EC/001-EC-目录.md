
## 01-让自己习惯 C++
### 条款 01：视 C++为一个语言联邦 View C++as a federation of languages.
1. C
	1. [x] 条款 2
	2. [x] 条款 13
2. Object-Oriented C++
3. Template C++
	1. [x] 条款 48
	2. [ ] 条款 46
4. STL
	1. [x] 条款 20
### 条款 02：尽量以 const，enum，inline 替换＃define Prefer consts，enums，and inlines to＃defines.
+ [x] 条款 48
+ [x] [[基础1 enum hack]]

### 条款 03：尽可能使用 const Use const whenever possible.
+ [ ] 条款 18
+ [x] 条款 20
+ [ ] 条款 27
+ [ ] [[基础8 bitwise const 和 logical constness]]
![[Pasted image 20231220162639.png]]
+ **const 在星星左边 物不变**
+ **const 在星星右边 指针不变**
+ **const 在星星两边 物和指针都不变**
![[Pasted image 20231220163011.png]]
> 两种形式都有人用，你应该试着习惯它们。

STL 迭代器系以指针为根据塑模出来，所以迭代器的作用就像个 T*指针。声明迭代器为 const 就像声明指针为 const 一样（**即声明一个 T*const 指针**），表示这个迭代器不得指向不同的东西，但它所指的东西的值是可以改动的。如果你希望迭代器所指的东西不可被改动（即希望 STL 模拟一个 const T*指针），你需要的是 [[const_iterator]]：
![[Pasted image 20231220163357.png]]
原来如此：
![[Pasted image 20231220163645.png]]
+ 两个成员函数如果只是常量性（constness）不同，可以被重载。这实在是一个重要的 C++特性。
#未看完



---
## 02-构造/析构/赋值运算
### 条款 07：为多态基类声明 virtual 析构函数 Declare destructors virtual in polymorphic base classes.
Factory 函数会“返回一个 base class 指针，指向新生成之 derived class 对象”：
![[Pasted image 20231220120007.png]]
+ [x] 条款 13  ： 倚赖客户执行 delete 动作，基本上便带有某种错误倾向
	+ [x] 使用智能指针
![[Pasted image 20231220153633.png]]
> 给 base class 一个 virtual 析构函数
> 	防止：诡异的“局部销毁”对象。这可是形成资源泄漏、败坏之数据结构、在调试器上浪费许多时间
> 任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数。

如果 class 不含 virtual 函数，通常表示它并不意图被用做一个 base class。当 class 不企图被当作 base class，令其析构函数为 virtual 往往是个馊主意。
> 会增加一个虚函数表。
> 	对象大小增加
> 	可移植性降低：c++>c 失败 （c 没有虚函数）

+ [ ] 条款 6
+ [ ] 条款 47
■ polymorphic（带多态性质的）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数。
■ Classes 的设计目的如果不是作为 base classes 使用，或不是为了具备多态性（polymorphically），就不该声明 virtual 析构函数。







---
## 03-资源管理
### 条款 13：以对象管理资源 Use objects to manage resources.
+ [x] 条款 7
+ [ ] 条款 8
+ [ ] 条款 14
+ [ ] 条款 18
+ [ ] 条款 16
+ [ ] 条款 14
+ [ ] 条款 15
+ [ ] 条款 18
以对象管理资源”的两个关键想法:
■ 获得资源后立刻放进管理对象（managing object）内 : [[智能指针]]，[[RAII]]
■ 管理对象（managing object）运用析构函数确保资源被释放。
> auto_ptr 和 tr1：：shared_ptr 两者都在其析构函数内做 delete 而不是 delete[]动作
> ![[Pasted image 20231220115458.png]]
> 

---

## 04-设计与声明
### 条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value Prefer pass-by-reference-to-const to pass-by-value.
+ [ ] 条款 34
+ [ ] 条款 36
> 对**内置类型**而言，当你有机会选择采用 pass-by-value 或 pass-by-reference-to-const 时，选择 pass-by-value 并非没有道理。
> 一般而言，你可以合理假设“pass-by-value 并不昂贵”的**唯一对象就是内置类型和 STL 的迭代器和函数对象**。至于其他任何东西都请遵守本条款的忠告，尽量以 pass-by-reference-to-const 替换 pass-by-value。

■ 尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可避免切割问题（slicing problem）。
■ 以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。
切割问题例子：
![[Pasted image 20231221153456.png]]


### 条款 24：若所有参数皆需类型转换，请为此采用 non-member 函数 Declare non-member functions when type conversions should apply to all parameters.
+ [ ] 条款 22
+ [ ] 条款 23
+ [x] 条款 20
+ [ ] 条款 21
+ [x] 条款 3

> 这导出一个重要的观察：member 函数的反面是 non-member 函数，不是 friend 函数。
> 	不能够只因函数不该成为 member，就自动让它成为 friend。

■ 如果你需要为某个函数的所有参数（包括被 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个 non-member。





---
## 05-实现
### 条款 31：将文件间的编译依存关系降至最低 Minimize compilation dependencies between files.
> 做好"**将接口从实现中分离**"这件事
![[Pasted image 20231211143603.png]]
+ [x] 条款 13
+ [x] [[基础5 pimpl idiom]]
> 这个分离的关键在于**以“声明的依存性”替换“定义的依存性”**，那正是编译依存性最小化的本质：**现实中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式（而非定义式）相依**。

■ 如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects
■ 如果能够，尽量以 class 声明式替换 class 定义式
+ [x] 条款 20
■ 为声明式和定义式提供不同的头文件。
+ [ ] 条款 30
+ [ ] 条款 16
+ [ ] 条款 34
+ [x] 条款 7
+ [ ] 条款 36
+ [x] 条款 13
+ [ ] 条款 18
+ [ ] 条款 40
+ [x] [[基础6 Handle classes]]
+ [x] [[基础7 Interface classes]]
■ 支持“编译依存性最小化”的一般构想是：**相依于声明式，不要相依于定义式**。基于此构想的两个手段是 Handle classes 和 Interface classes。
■ 程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及 templates 都适用。








---
## 06-继承与面向对象设计
### 条款 32：确定你的 public 继承塑模出 is-a 关系 Make sure public inheritance models"is-a."
> 以 C++进行面向对象编程，最重要的一个规则是：
> 	**public inheritance（公开继承）意味 "is-a"（是一种）的关系。**
> 		> 如果你令 class D（"Derived"）以 public 形式继承 class B（"Base"），你便是告诉 C++编译器（以及你的代码读者）说，每一个类型为 D 的对象同时也是一个类型为 B 的对象，反之不成立。你的意思是 B 比 D 表现出更一般化的概念，而 D 比 B 表现出更特殊化的概念。你主张“B 对象可派上用场的任何地方，D 对象一样可以派上用场”（译注：此即所谓 Liskov Substitution Principle），因为每一个 D 对象都是一种（是一个）B 对象。反之如果你需要一个 D 对象，B 对象无法效劳，因为虽然每个 D 对象都是一个 B 对象，反之并不成立。
> ![[Pasted image 20231211115903.png]]
> 根据生活经验我们知道，每个学生都是人，但并非每个人都是学生。这便是这个继承体系的主张

+ [x] 条款 38 (has-a)
+ [x] 条款 39 (is-implemented-in-terms-of)
### 条款 38：通过复合塑模出 has-a 或“根据某物实现出” Model"has-a"or"is-implemented-in-terms-of"through composition.
### 条款 39：明智而审慎地使用 private 继承 Use private inheritance judiciously.
■ Private 继承意味 is-implemented-in-terms of（根据某物实现出）。它通常比复合（composition）的级别低。但是当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的 virtual 函数时，这么设计是合理的。
■ 和复合（composition）不同，private 继承可以造成 empty base 最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。
+ [x] 条款 31
+ [ ] 条款 18
+ [ ] 条款 35
+ [ ] 条款 50
+ [x] EBO（empty base optimization；空白基类最优化）
+ [x] [[基础4 空白基类最优化]]
![[Pasted image 20231211141702.png]]
1. “阻止 derived classes 重新定义 virtual 函数”的能力


---

## 07-模板与泛型编程
### 条款 46：需要类型转换时请为模板定义非成员函数 Define non-member functions inside templates when type conversions are desired.
+ [x] 条款 24
+ [x] 条款 20
+ [ ] 条款 28


### 条款 47：请使用 traits classes 表现类型信息 Use traits classes for information about types.
+ [x] 条款 32 (is-a)
+ [ ] 条款 42
+ [x] [[基础3 STL的五种迭代器]]
### 条款 48：认识 template 元编程 Be aware of template metaprogramming.
+ [x] 条款 47
+ [ ] 条款 21
+ [ ] 条款 44
+ [x] [[基础2 expression templates]]


---

## 09-杂项讨论
### 条款 53：不要轻忽编译器的警告 Pay attention to compiler warnings.
### 条款 54：让自己熟悉包括 TR1 在内的标准程序库 Familiarize yourself with the standard library，including TR1.
> 时代产物
### 条款 55：让自己熟悉 Boost Familiarize yourself with Boost.
> 针对 TMP 而设计的程序库（例如 Boost's MPL）
