STL 共有 5 种迭代器分类，对应于它们支持的操作。

[[Input 迭代器]]只能向前移动，一次一步，客户只可读取（不能涂写）它们所指的东西，而且只能读取一次。它们模仿指向输入文件的阅读指针（read pointer）；C++程序库中的 [[istream_iterators]] 是这一分类的代表。

[[Output 迭代器]]情况类似，但一切只为输出：它们只向前移动，一次一步，客户只可涂写它们所指的东西，而且只能涂写一次。它们模仿指向输出文件的涂写指针（write pointer）；[[ostream_iterators]] 是这一分类的代表。

> 这是威力最小的两个迭代器分类。由于这两类都只能向前移动，而且只能读或写其所指物最多一次，所以它们只适合“一次性操作算法”（one-pass algorithms）。

另一个威力比较强大的分类是 [[forward 迭代器]]。这种迭代器可以做前述两种分类所能做的每一件事，而且可以读或写其所指物一次以上。这使得它们可施行于多次性操作算法（multi-pass algorithms）。STL 并未提供单向 linked list，但某些程序库有（通常名为 slist），而指入这种容器的迭代器就是属于 forward 迭代器。

[[Bidirectional 迭代器]]比上一个分类威力更大：它除了可以向前移动，还可以向后移动。STL 的 list 迭代器就属于这一分类，set，multiset，map 和 multimap 的迭代器也都是这一分类。

最有威力的迭代器当属 random access 迭代器。这种迭代器比上一个分类威力更大的地方在于它可以执行“迭代器算术”，也就是它可以在常量时间内向前或向后跳跃任意距离。这样的算术很类似指针算术，那并不令人惊讶，因为 random access 迭代器正是以内置（原始）指针为榜样，而内置指针也可被当做 random access 迭代器使用。vector，deque 和 string 提供的迭代器都是这一分类。